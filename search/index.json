[{"content":"第四单元博客\r正向建模与开发分析\r总结本单元所实践的正向建模与开发\n正向建模与开发，即先进行系统架构的设计，再进行代码的实现。在本单元中，正向建模与开发体现为先规划设计 UML 的类图等、再进行代码的编写。在这一单元中，正向建模要求我们每次作业都先通读指导书，通过对需求进行一定深度的分析，建立每次作业对应的架构设计，再开始代码的编写。\n显然，系统架构的设计无法一蹴而就，它需要经过深思熟虑和反复的迭代。在本单元的实践中，我反复执行了以下过程：首先对项目需求进行了详尽的分析，然后进行较为整体的规划，进而开始代码的编写，在具体的实现中又会涌现出新的细粒度的需求。\n这一单元中，我使用了统一建模语言（UML）来创建类图、序列图、状态图等，这些图帮助我可视化系统的不同组件以及它们之间的交互，如借还处、预约处、书架、漂流角之间书籍的流动。通过这些图，我更好地理解了系统的结构，得以预测潜在的问题，确保设计足够完善。\n在设计阶段，我注重模块化和可扩展性，以便于未来的维护和升级。我在本单元第一次作业中设计的六个类，一直到第三次作业也没有产生新的类来分割功能，而其运行逻辑也仍然显得清晰明了，这不仅得益于课程组设计上的仁慈，也小小地来自于我在最初设计时注重的可扩展性。\n在编码阶段，我遵循之前设计的架构蓝图，着手编写高质量的代码。我总是及时使用 Git 来管理代码的变更，每次提交的修改范围往往仅局限于一个类文件，这不仅有助于我发现潜在的代码逻辑问题，也使得我有时横跨多日的开发流程能够进行比较流畅的衔接。\n最后，我利用野生的评测机进行高强度的黑盒测试，以减少在强测中出错的可能。\n通过本单元的实践，我认识到了正向建模与开发的重要性和复杂性，虽然这种方法可能需要更多的前期工作和规划，但它能够带来更加健壮和可维护的软件系统。\n架构设计分析\r在本单元中，我通过启动一个 Controller 线程来处理输入，根据解析后的命令类型分发命令给不同的对象，如借还处处理借书和还书、预约处处理预定和拿书等，整体而言职责分配比较明晰。\nController：作为系统的核心，Controller 线程负责接收和解析命令，然后根据命令类型分发至相应的处理模块。 Facebook：负责用户信用评分的管理，以及借书和预定书籍的记录。 Bookstore：模拟图书馆的书架，管理书籍的存储和检索。同时作为基础的功能类，借还处、预约处、漂流角都有对应的一个该类对象。 Circulation：处理借书和还书的逻辑。 Reservation：管理用户的图书预定请求，处理预定和取书的逻辑。 Cart：负责在开馆和闭馆时执行任务，如检查逾期书籍和更新预约状态。 代码设计与 UML 模型设计追踪关系分析\r维护代码设计和 UML 模型设计的统一性是一个动态的过程。随着时日推移，需求变更是不可避免的，这种变更需要及时反映在 UML 模型和代码设计中，以确保两者之间的一致性。\n从 UML 模型设计更新代码设计：在本单元中，我每次作业都首先设计 UML 模型，设计出一些必要的方法，再对其进行代码的实现（不过后面才发现似乎有工具可以直接从设计好的模型生成代码）。\n从代码设计更新 UML 模型设计：在实际进行代码编写的过程中，难免会出现一些没用预想到的或者辅助的方法，这时候我总是选择对这些方法先进行 // TODO UML 的标记，以提醒自己要在 UML 模型中进行更新。在需求发生变更的时候（如 hw14 中官方包规格发生较大的变化），我也会对方法参数的变化进行标记，最后再统一更新 UML 模型。\nOO课程架构设计分析\r总结自己在四个单元中架构设计思维的演进\n第一单元架构设计体验\r在第一单元的学习中，我深刻体会到了架构设计的重要性。通过对程序结构的度量分析，我认识到了类的设计应追求高内聚低耦合的原则。由于做了一定程度的预习知道了递归下降，加上上个学期对 oopre 课程的学习，虽然经历了一次重构，但是总归是顺利地实践了较好地架构。现在回过头看第一单元的架构设计，尽管类的设计在功能上能够满足需求，但在内聚性和耦合度上仍有改进空间。例如，一些类承担了过多的职责，导致代码的可读性和可维护性降低。在未来的设计中，我将更加注重单一职责原则，确保每个类都有明确的功能边界。\n第二单元多线程交互设计\r在第二单元，我主要关注了调度器设计以及线程间的交互。通过分析同步块的设置和锁的选择，我意识到合理的架构设计对于程序性能和线程安全至关重要。这一单元的架构设计其实课程组没有强加什么限制，正如一位同学最后一段时间在讨论区提出的“完全影子电梯”，甚至可以单线程、高性能地满足课程组的要求。也是在这个时候我意识到了，没有完美的架构，只能不断改进。这一单元我主要应用了生产者-消费者模型，架构的设计也围绕其进行。一个做的不够好的点是，电梯调度器的类代码行数写的太多了（400多行），一方面是电梯运行的逻辑比较复杂，一方面可能职责可以进一步分离。比较欣慰地是，由于做的时候一直在思考怎么实现影子电梯，所以整体架构的设计也复用了相当多的代码，可以兼容实际电梯和影子电梯，我个人还是很满意的。而且得益于自己写了评测机并使用了白盒测试，本单元的架构较好地满足了多线程的运行要求。\n第三单元规格化设计\r第三单元的学习让我认识到了规格化语言在架构设计中的作用。课程组在官方包中对足够多的方法提出了要求，通过引入一定量的算法，我较为成功地完成了此单元的架构实现。现在回过头来看，其实相当于课程组基本固定了本单元的架构设计，最多要自己额外实现的类不超过两个，这也算 JML 这类规格语言最大的用处了。\n第四单元正向建模与开发\r在第四单元，我进一步深化了对正向建模的理解。通过正向建模，我能够在开发前期就对系统有一个清晰的认识，并设计出更加合理的架构。我学会了如何将需求转化为模型，并在模型的基础上进行开发，这大大提高了我的开发效率和代码质量。\n测试思维分析\r主要和 YEZ 同学一起开发评测机\n第一单元\r一开始利用学长开源的评测机代码，利用 sympy 库化简得到正确答案，再与程序输出进行比较。 随着作业内容的增加， sympy 库逐渐显得乏力，经历了代值判等法的过渡方法，到最后的基本为对拍的方法。 黑盒测试。 第二单元\r数据生成比较简单，本单元评测机的难点主要是编写检查程序，我采用的方法是为电梯系统的每条输出都进行合法性检查，虽然代码量很大，但是确实取得了不错的效果。 此外考虑到第一单元进行测试时已经遇到的测试速度过慢问题，我们从这一单元开始通过 Python 的 subprocess 库引入了多进程评测，不仅有效地提高了评测速度，而且有助于引发多线程程序的各种问题，如死锁和竞态条件，得到了不错的测试效果。 黑盒测试。 第三单元\r写了一些针对特殊指令的数据生成，主要还是利用随机生成的方式来生成数据。 但是偷懒没有引入常量池，居然爆 int 了。。。而且有一个很小的点，写了一个小 TLE，哎，不要为打翻的牛奶哭泣！ 发掘了分析有效数据行的方法，中心思想是滚雪球+二分筛选，还是很有用的。 黑盒测试。 第四单元\r用了野生评测机，没自己写。\n课程收获\r第一次在同个项目中写这么多代码，虽然以后看起来或许微不足道，但毕竟迈出了第一步 学习到了一些代码架构的经验？希望在软工等课程中能够好好发挥 评测机，现在看起来自己写的收益也不算低，居然还收获了个狼人奖 写出了几次低级错误，真是葬送好局啊。。。但是就这样吧，尽兴就好，不要为打翻的牛奶哭泣 至少学下来觉得面向对象的思想还是挺好的 每次想起这课只有 3 学分就觉得有点 crazy。 感谢老师、助教、同学们。 ","date":"2024-09-04T00:00:00Z","permalink":"http://localhost:1313/p/oo-u4-doc/","title":"OO | Unit 4"},{"content":"第三单元博客\r测试过程分析\r黑箱测试与白箱测试\r黑箱测试：具体到本单元的测试中，我通过 生成数据 -\u0026gt; 交给程序运行 -\u0026gt; 得到输出进行对拍 的流程来实践了黑箱测试，也就是不涉及程序的内部逻辑，仅按照同一个测试用例下输出是否一致来测试程序的功能和行为是否符合预期，显然在课程组的评测系统中，也使用的是黑箱测试（中测、强测）。这样的测试方法依赖于测试数据的强度，若测试数据强度不足则无法发现程序的全部内部错误。\n白箱测试：具体到本单元的测试中，我通过使用 JUnit 来实践了白箱测试。白箱测试用于发现程序错误的方式与黑箱测试稍有不同，区别在于白箱测试需要对程序的内部实现有严格的测试，包括对相关规格的逐条验证、对分支结构的充分覆盖等，因而需要测试程序对期望程序的规格结构有充分的覆盖。这样的测试方法如果设计得好，则可以最大程度地测试出程序的所有不符合规格的地方；然而设计这样的测试方法，需要同等甚至多于编写原程序的时间和精力。\n对一系列测试的理解\r单元测试：对软件中最小的可测试部分（如函数和方法）进行测试，旨在验证这些最小代码单元按照预期工作，例子是本单元中每次与中测一同出现的特殊 JUnit 测试，均要求对特定的方法进行测试。 功能测试：验证程序的功能是否满足需求的测试。在本单元中，我认为每行合法的输入其实都对应一种要求的功能，所以功能测试包含在了我的黑箱测试当中，因为每个功能是否正确实现不仅表现于对应行的输出是否正确，也可以通过后续有耦合的功能的对应输出进行判断。即如果实现不当，错误功能的外在表现会体现在此条及之后的输出之中。但正如上文叙述的，黑箱测试并不能保证发现功能的所有错误。 集成测试：在单元测试之后进行，目的是验证不同模块或组件如何协同工作。其实我实践的黑箱测试更偏向于一种系统测试，其在一定程度上也能完成集成测试的目的，即从结果上验证了功能模块之间协同工作的效果。要完整地实践集成测试，应该首先全面地完成单元测试，然后再仅针对模块间的交互行为进行测试的设计。然而本单元的作业交互程度其实并不高，即交互行为较少、各功能之间较为独立，实现集成测试的性价比不如系统测试。 压力测试：验证软件在极端工作条件下的行为，如高负载或有限资源。在本单元中，内存空间较为宽裕，对软件性能的验证主要在于运行时间，需要压力测试来验证程序的实现是否足够高效。就具体实现而言，我利用 Python 的 Subprocess 库进行了多进程测试，并对测试数据生成的逻辑和规模进行了设计。然而课程组的评测机对计算性能的限制有点超乎想象了，在 hw9 中的一个小功能处，我未能注意到写了一个二重循环，使得方法的复杂度来到了 O(n^2) ，遗憾的挂掉了一个点。然而要复刻到课程组的硬件环境是相当困难的，因此在程序设计的过程中还是尽量要多卷卷性能，多注意方法的复杂度。实际上对于不多于 10000 条的数据，需要保证复杂度低于 O(n^2)。 回归测试：在软件发生更改后进行的测试，以确保现有功能仍然按预期工作。在本单元中，我对回归测试的实践在于将写完的程序打包为 jar 文件，再次投入到前一次作业的评测机中进行测试，以确保没有修改原有的规格。 数据构造策略\r由于主要采用了黑箱测试的方法，本单元的评测机对数据构造的依赖性较强。\nhw9：主要采用了随机生成指令，仅保证了数据生成符合数据限制，所以数据强度较低。 hw10：参考了课程组的数据生成，使用 ln 指令指定生成了稀疏图或稠密图；同时还设计了一些数据生成分支，对诸如 qtvs 这样的指令进行了功能测试；然而本单元未考虑到像第一单元一样为 int 型数据设计常量池，导致未测试出 int 型比较时直接使用减法导致溢出的问题；而且后来发现对 JML 规格的测试不够全面，比如未考虑到 att 指令中对 tagSize 不大于 1111 与否时不同的行为，导致其实我们评测机没有覆盖到强测考虑到的所有情况。 hw11：添加了对消息类指令的支持，对生成方式采用了大量数据（10w+条）+少量测试的做法，并主要在有效指令筛选部分下了点功夫。据测试，这样的生成方式有更大的概率检验出程序错误，原因是往往构造了更加复杂的图，或者随机指令命中了特定的关系。虽然这样的生成方式会造成大量无效的指令，但是可以通过一种二分广搜的方法大概确定有效但稀疏指令的位置，从而将总指令数在几分钟内降低至一百余条，其实也很有利于互测数据构造和故障定位。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def bfs_search(lines, take_01): queue = deque([(0, len(lines) - 1)]) # 初始区间为[0, len - 1] while queue: start, end = queue.popleft() if start + 16 \u0026gt; end: # 不必精确到每条指令，故最小区间可以进行设置 continue # 如果区间无效，跳过 print(f\u0026#34;line num: {sum(take_01)}, queue num: {len(queue)}\u0026#34;) # 创建一个临时的take_01列表，用于检查当前区间 assert check_constraints(take_01, lines) temp_take_01 = take_01.copy() for i in range(start, end): temp_take_01[i] = 0 # 检查当前区间是否满足约束条件，即代码对拍是否出错 if check_constraints(temp_take_01, lines): print(f\u0026#34;[{start}, {end}] deleted\u0026#34;) # 如果满足，将对应的take_01设置为负数 for i in range(start, end + 1): take_01[i] = 0 # 如果当前区间不满足约束条件，将其二分并加入到队列中 elif start != end: mid = (start + end) // 2 queue.append((start, mid)) queue.append((mid + 1, end)) return take_01 with open(\u0026#39;filtered_output.txt\u0026#39;, \u0026#39;r\u0026#39;) as input_file: lines = input_file.readlines() take_01 = [1] * len(lines) # 执行广度优先搜索 take_01 = bfs_search(lines, take_01) # 使用更新后的take_01列表来写入新的input.txt with open(\u0026#39;input.txt\u0026#39;, \u0026#34;w\u0026#34;) as out: for i, line in enumerate(lines): if take_01[i] \u0026gt; 0: out.write(line.rstrip() + \u0026#34;\\n\u0026#34;) 架构设计分析\r社交网络图\r使用并查集的数据结构作为主体，实现了并查集的查找、路径压缩、启发式合并，以支持如下几个功能：\n查找：动态维护 blockSum，直接支持 isCircle 方法 合并：对应 addRelation 方法 染色删边：并查集并不包含复杂度低的删边方法，所以借鉴学长的博客，我采用了一种形式上像染色的使用广搜的删边方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private final HashMap\u0026lt;Integer, Integer\u0026gt; pa = new HashMap\u0026lt;\u0026gt;(); public void unlink(int x, int y) { pa.replace(x, x); paMark(y); if (pa.get(x) != y) { paMark(x); } } private void paMark(int id) { ArrayDeque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; marked = new HashSet\u0026lt;\u0026gt;(); queue.add(id); while (!queue.isEmpty()) { int currId = queue.remove(); if (!marked.contains(currId)) { marked.add(currId); pa.replace(currId, id); queue.addAll(((MyPerson) persons.get(currId)).getAcquaintance()); } } } 这种做法的好处在于不需要对并查集进行全局的重建，一般情况下仅需要进行局部的重建。据我所知有同学对于并查集删边的处理为延迟的全局重建，但考虑到最坏情况可能超时，我最终还是采用了这种实时的局部重建，并加入到 modifyRelation 方法中。\n维护策略\r对并查集的维护不再赘述。\n对简单值的维护\r在本单元的社交网络中，我对 tripleSum 、 blockSum 、 coupleSum 都进行了维护，但显然维护亦分两种情况：\n实时更新，即动态维护，在每个可能修改值的内容的地方直接将值进行更新，往往涉及到一些判断，在我的实现中 tripleSum 、 blockSum 为动态维护 脏位维护，即在每个可能修改值的内容的地方进行记录，在查询时根据脏位来决定是否需要更新值。在我的实现中，例子为 coupleSum 和 coupleCached 使用观察者模式进行维护\r在 hw10 加入的 tag 系统中，我使用了观察者模式来维护关系发生变化时 tag 包含的 persons，如使用了 followerToTags 容器：\n1 private final HashMap\u0026lt;Integer, HashMap\u0026lt;Integer, HashSet\u0026lt;Tag\u0026gt;\u0026gt;\u0026gt; followerToTags = new HashMap\u0026lt;\u0026gt;(); 利用这个容器，我在 delTag 、 delPersonFromTag 、 addPersonToTag 、 followerToTags 和一些辅助方法中，得以使用观察者模式而不是遍历来对 tag 进行维护，提升了 qtvs 方法的性能。\n使用 TreeSet 进行维护\r在 hw10 加入的 queryBestAcquaintance 方法中，要求查询满足条件的 bestId，所以我对 MyPerson 类的 acquaintance 容器进行了改造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private final TreeSet\u0026lt;Person\u0026gt; acquaintance = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person p1, Person p2) { int id1 = p1.getId(); int id2 = p2.getId(); int cmp = Integer.compare(idToValue.getOrDefault(id2, Integer.MAX_VALUE), idToValue.getOrDefault(id1, Integer.MAX_VALUE)); if (cmp == 0) { return Integer.compare(id1, id2); } else { return cmp; } } }); // 集合性 private final HashMap\u0026lt;Integer, Integer\u0026gt; idToValue = new HashMap\u0026lt;\u0026gt;(); 利用 TreeSet 进行维护使查询的复杂度降低到了 O(1)，提升了性能，也使得代码更加优雅。\n性能问题及其修复\r千里之堤，溃于蚁穴\nhw9\r在维护 tripleSum 的时候写出了如下的代码：\n1 2 3 4 5 6 7 for (int acId1: p1.getAcquaintance()) { for (int acId2: p2.getAcquaintance()) { if (acId1 == acId2) { tripleSum += 1; } } } 然后悲剧地超时了。回头看了一眼只有这个地方写了一个二重循环，不过由于是写在了调用比较频繁的 addRelation 和 modifyRelation 中，所以超时也没什么好说的。后面改成了如下的写法：\n1 2 3 Set\u0026lt;Integer\u0026gt; interSet = new HashSet\u0026lt;\u0026gt;(p1.getAcquaintance()); interSet.retainAll(p2.getAcquaintance()); tripleSum += interSet.size(); 时间就少了不少。可惜我在别的地方花了那么多时间，最后还挂了一个点 :（\nhw10\rTreeSet 与爆 int\r在重写容器 acquaintance 时写出了如下的代码：\n1 2 3 4 5 6 7 8 9 10 private final TreeSet\u0026lt;Person\u0026gt; acquaintance = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person p1, Person p2) { int id1 = p1.getId(); int id2 = p2.getId(); int cmp = idToValue.getOrDefault(id2, Integer.MIN_VALUE) - idToValue.getOrDefault(id1, Integer.MIN_VALUE); // 降序 return cmp == 0 ? id1 - id2 : cmp; // 升序 } }); // 集合性 写完觉得自己的写法真是简洁优雅啊，然而爆 int 了。这里的 bug 在于比较 int 型数据的时候不能直接相减，会造成溢出。所以改成了如下的安全的写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private final TreeSet\u0026lt;Person\u0026gt; acquaintance = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person p1, Person p2) { int id1 = p1.getId(); int id2 = p2.getId(); int cmp = Integer.compare(idToValue.getOrDefault(id2, Integer.MIN_VALUE), idToValue.getOrDefault(id1, Integer.MIN_VALUE)); if (cmp == 0) { return Integer.compare(id1, id2); } else { return cmp; } } }); // 集合性 Integer.compare() 大法好，如果早点知道有这个用法就更好了 :（\n关于最短路径\r关于最短路径的查询，考虑到本单元社交网络无权图的特性，显然应该采用广搜这样的算法而不是迪杰斯特拉这种适用于带权图的算法。为了进一步的性能优化，我还采用了双向BFS的实现，这种写法相比简单BFS的优势主要在于，考虑到了两个点之间的通路呈纺锤形的情况。一个小优化在于，可以优先遍历相邻节点更少的那一侧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Override public int queryShortestPath(int id1, int id2) throws PersonIdNotFoundException, PathNotFoundException { findPersonId(id1, id2); if (pa.find(id1) != pa.find(id2)) { throw new MyPathNotFoundException(id1, id2); } else if (id1 == id2) { return 0; } int dis = -1; ArrayDeque\u0026lt;Integer\u0026gt; queue1 = new ArrayDeque\u0026lt;\u0026gt;(); queue1.add(id1); ArrayDeque\u0026lt;Integer\u0026gt; queue2 = new ArrayDeque\u0026lt;\u0026gt;(); queue2.add(id2); Set\u0026lt;Integer\u0026gt; visited1 = new HashSet\u0026lt;\u0026gt;(); visited1.add(id1); Set\u0026lt;Integer\u0026gt; visited2 = new HashSet\u0026lt;\u0026gt;(); visited2.add(id2); while (!queue1.isEmpty() \u0026amp;\u0026amp; !queue2.isEmpty()) { dis++; if (queue1.size() \u0026lt;= queue2.size()) { if (updateBiBfs(queue1, visited1, visited2)) { break; } } else { if (updateBiBfs(queue2, visited2, visited1)) { break; } } } return dis; } private boolean updateBiBfs(ArrayDeque\u0026lt;Integer\u0026gt; q, Set\u0026lt;Integer\u0026gt; visited, Set\u0026lt;Integer\u0026gt; other) { ArrayDeque\u0026lt;Integer\u0026gt; thisFloor = new ArrayDeque\u0026lt;\u0026gt;(q); while (!thisFloor.isEmpty()) { Integer curr = q.pollFirst(); thisFloor.removeFirst(); for (int ac : ((MyPerson) persons.get(curr)).getAcquaintance()) { if (visited.contains(ac)) { continue; } if (other.contains(ac)) { return true; } visited.add(ac); q.add(ac); } } return false; } hw11\r关于 Person 类中的 messages 容器，相关方法要求返回一个 List\u0026lt;Message\u0026gt; 对象，所以自然地我们会想到用 ArrayList 或者 LinkedList 来实现。然而注意到 addMessage 方法总是在开头插入，而 ArrayList 对象执行 add 方法在头部插入时会对底层数组进行整体复制，影响整体效率，所以这里应该采用 LinkedList 来实现。\n关于规格与实现分离\rJML 的规格包括前置条件、后置条件、可能的异常，这种写法的规范性无需多言。设想现在有甲方和乙方，甲方负责以 JML 的形式来提出要求，乙方负责进行实现，有助于实现软件开发过程中的清晰沟通和责任分工。在我进行冯如杯项目开发的时候，其实碰到过几次组员以意向不到的方式修改了代码的实现、从而影响到了别的模块的情况，所以刚接触 JML 这个概念的时候就觉得这样的规格说明是一种不错的做法。\n另一方面，规格与实现分离也对程序性能没有造成损害。虽然在规格的说明中，JML 往往会采用多重循环等复杂度较高的方式来说明前后置条件，但是我们的实现仅需要满足规范，而不是完全逐字翻译 JML。在以往的开发中，我对函数的认识仅在于接受什么样的输入、应该给出什么样的输出，而 JML 对应该改变哪些内容、不应该改变哪些内容也做出了限制，在规范化的同时，保证了核心功能容器和辅助功能容器的分离，其实也有利于解耦。\n规格与 JUnit 测试\r本单元中同学们实现了Junit测试方法，总结分析如何利用规格信息来更好的设计实现Junit测试，以及Junit测试检验代码实现与规格的一致性的效果\n本单元提出了一种特殊的测试方法，即编写 JUnit 测试，对课程组提供的错误代码按照规格进行检测。这类测试保证其他方法均正确实现，故可以调用其他正确方法来进行社交网络的构造和相关规格检验对象的获取。在实现 JUnit 测试的过程中，我认为最重要的就是两个相辅相成的要点：保证数据生成的覆盖率和断言的全面性。\n数据生成的覆盖率：没有全面的数据，就难以触发错误代码对规格的违反。所以在 JUnit 测试中，应该注意对要测试方法的所有有关属性进行充分的改变，在足够多样的环境中尝试进行断言测试。 断言的全面性：要保证对 JML 规格进行全面的翻译，不能落下任何一条语句。而且相比于使用 if-else 来对一些规格中的条件进行判断，我还看到了一种很合适的实现方法，即 1 assertTrue((!(oldMessages[j] instanceof MyEmojiMessage \u0026amp;\u0026amp; myNetwork.containsEmojiId(((EmojiMessage) oldMessages[j]).getEmojiId()))) || (hasMessage(oldMessages[j], nowMessages))); 可以看到这种实现是最大程度保留了 JML 的原味，尽管我并不了解测试岗位应该写出怎么样的测试程序，但对于 JML 规格的实现，我觉得这种直接的翻译是最好看的。\n学习体会\r据不完全统计，本单元一共出现 14 次更正，其中 3 次为评测机错误， 4 次为 JML 代码的非合并修复，与前两单元相比可谓是遥遥领先。[1]\n初次接触前置条件与后置条件，我觉得很正确，并会将其加入到以后的软件工程开发中，以避免 Post-Effect。 希望对 JUnit 的测试中可以提供更多信息的反馈，或者设计单独的评测，我觉得靠同学间的探索和交流来猜测错误代码有什么问题的现象对于学习如何进行测试没有什么意义。 课程组对 JML 进行了一定程度的魔改，但也因此失去了检验其正确性的工具，希望早日开发相应的自动化工具，让规格也更加规范化，避免热修复，毕竟每周作业时间也是很紧张的。 ","date":"2024-09-03T00:00:00Z","permalink":"http://localhost:1313/p/oo-u3-doc/","title":"OO | Unit 3"},{"content":"第二单元博客\r多线程——同步和锁\r总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系\n本单元开发是严格的迭代开发，故本主题重点分析第七次作业。\n同步方法\r本单元作业中使用较多的一种方法，即使用 synchronized 关键字作为函数的修饰符。在这种实现中，当前类对象即为锁。如 RequestQueue 类中，我对 add、take 等方法使用了同步块，以控制输入线程、分发器线程、电梯线程（RESET 时返还请求）对 RequestQueue 对象进行读写时不发生冲突，保证对临界资源操作的互斥性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public synchronized void add(PersonRequest pr) { long tmpTime = System.currentTimeMillis(); Person tmp = new Person(pr.getPersonId(), pr.getFromFloor(), pr.getToFloor(), tmpTime); this.requests.add(tmp); notArrived += 1; notifyAll(); } public synchronized void add(ArrayList\u0026lt;Person\u0026gt; people) { this.requests.addAll(people); notifyAll(); } public synchronized Person take() { notifyAll(); while (requests.isEmpty() \u0026amp;\u0026amp; (!this.end || this.resetTimes != 0 || notArrived != 0)) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } if (requests.isEmpty()) { return null; } Person pr = requests.get(0); requests.remove(0); return pr; } 同步代码块\r即使用 synchronized 关键字作为函数内的语句，在括号内声明作为锁的对象。以 outByFloor 对象为例，其为一个 HashMap 对象，记录每层楼要下电梯的用户信息。我为其创建同步代码块、将其作为锁，以确保对其的访问和修改是线程安全的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public EleAction getNextStep() { int currFloor = elevator.getCurrFloor(); if (elevator.getState() == EleState.IDLE) { // ... synchronized (outByFloor) { if (outByFloor.containsKey(currFloor) || sameDirReq()) { return EleAction.OPEN; } } // ... } else { // ... synchronized (outByFloor) { if (outByFloor.containsKey(currFloor)) { return EleAction.OUT; } } // ... } } public ArrayList\u0026lt;Person\u0026gt; outPerson() { // ... synchronized (outByFloor) { if (outByFloor.containsKey(currFloor)) { ArrayList\u0026lt;Person\u0026gt; tmp = outByFloor.get(currFloor); Iterator\u0026lt;Person\u0026gt; it = tmp.iterator(); // remove if (tmp.isEmpty()) { outByFloor.remove(currFloor); } } // ... } } private ArrayList\u0026lt;Person\u0026gt; removeAllPassengers() { synchronized (outByFloor) { for (ArrayList\u0026lt;Person\u0026gt; tmp: outByFloor.values()) { // ... } outByFloor.clear(); } // ... } 使用实现Lock接口的类\r在实现双轿厢电梯时，我规定形如由 1-A / 1-B 接收的乘客，最后也会在最多一次换乘后由 1-A / 1-B 送达，故使用了 notArrived 变量来记录有多少个请求还没有到达目的地。为了保证对这个变量的读写是线程安全的，我使用了 ReentrantReadWriteLock 类对不同的写操作进行控制，以保证在任何给定时间点，只有一个线程可以增加或减少notArrived的值。当然为了在 getter 方法中等待的线程可以被唤醒，这些修改值的方法还被 synchronized 关键字修饰，并在最后进行了 notify 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class TheFloor implements Serializable { // ... private int notArrived = 0; private final ReentrantReadWriteLock.WriteLock writeLock; public TheFloor() { // ... ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); writeLock = lock.writeLock(); } public synchronized void addNotArrived() { writeLock.lock(); notArrived += 1; writeLock.unlock(); notifyAll(); } public synchronized void addArrived(int i) { writeLock.lock(); notArrived -= i; writeLock.unlock(); notifyAll(); } 锁与同步块中处理语句之间的关系\r总的而言，锁与同步块中处理语句之间的关系有如下几种：\n保证互斥性：锁是同步块中语句互斥性的保证，通过对对象上锁，程序保证多个线程对同步块内语句的执行是互斥的，这些语句往往包含对临界资源的修改，有时候使用资源对象作为锁，也可以使用诸如 ReentrantReadWriteLock 类的对象作为锁，但后者更需要注意对同步块边界的设置。 条件等待与唤醒：在 synchronized 修饰的同步块中，可以使用 wait() 、 notify() 和 notifyAll() 来进行线程间的协调。例如，在 RequestQueue 的 take() 方法中，如果队列为空，线程将调用 wait() 进入等待状态。当有新请求添加到队列时，通过调用 notifyAll() 唤醒所有等待的线程。 锁的获取与释放：在本次作业中，我基本都是使用 synchronized 关键字实现同步和互斥，考虑其中锁的获取与释放的话，synchronized 修饰的代码块前后会自动进行锁的获取和释放，并且其同步块是可重入的，即如果一个线程已经获取了某个锁对象的锁，并且再次进入一个以相同锁对象同步的同步块，它可以直接进入而不会被阻塞。如果使用诸如 ReentrantReadWriteLock 类的对象作为锁，需要注意在同步块前后进行锁的获取和释放。 调度器设计分析\r调度器如何与程序中的线程进行交互？画 UML 协作图 (sequence diagram) 来展示线程之间的协作关系\n由 UML 协作图可见，调度器线程由主线程创建并启动，通过请求队列间接与输入线程交互，包括获取乘客对象、获得预更换信号和接收结束信号；在与电梯线程交互时，调度器线程需要根据请求分配乘客对象给电梯线程、接收普通电梯线程重置完成的信号并启动双轿厢电梯线程；在结束时，调度器线程还需要从请求队列接受结束信号，并传递给管理的电梯线程。\n调度策略分析\r总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的\n一、单部电梯运行策略\r借鉴了磁盘调度算法中的 LOOK 算法，在我的实现中，电梯从可达区域的一端开始工作，然后移动到另一端，并在途中服务所有可捎带同向请求。当电梯达到一端的最后一个请求点（包括上车和下车）时，它改变方向并继续运行。虽然条件所限无法与其他可能的电梯调度算法进行对比，但是就脑测而言，这种算法对运行时间、耗电量还算表现好，响应时间可能表现略差。\n这个架构在 hw5 基本已经成型，hw6 对其只进行了增量开发，hw7 更是直接让双轿厢电梯继承了单部电梯的大部分运行策略并稍加修改。\n一些实现细节\r由于我实现了电梯策略和电梯线程的分离，在线程的 run() 方法内采用了状态机的思想进行实现；而在电梯策略类中，我会根据电梯的状态为 IDLE 或 WORK 给出进一步的决策。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // ElevatorThread.java @Override public synchronized void run() { while (scheduler.notEnd()) { switch (elevator.getState()) { case IDLE: actIdle(); break; case WORK: actWork(); break; default: TimableOutput.println(\u0026#34;ERROR IN ET SWITCH\u0026#34;); break; } } // ... } // Scheduler.java public EleAction getNextStep() { int currFloor = elevator.getCurrFloor(); if (elevator.getState() == EleState.IDLE) { if (this.toReset) { return eleActionWhenReset(); } if (waitList[0] == 0) { return EleAction.WAIT; } // ... } else { // ... } } 同楼层同方向请求有多个，考虑到电梯容量的限制，先接哪一个？其实这里我做的考虑不是很周到，主要是考虑到如果一层（例如为2）有 7 个同向请求（例如为3到9），电梯容量为 6，应该少接哪一个？如认为不会再有新请求，可以先不接去 3 层的，可以提高总运行时间和功率的表现；要再细究的话，可以根据已有请求目的地距离、手头有的两个请求的距离进行选择，所以这里我做了一个简单的排序。实际上因为考虑的情形太少，可能这里还不如不排序、按照先来后到上乘客，这样 MT 还能低点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public synchronized void inPerson() { synchronized (waitByFloor) { ArrayList\u0026lt;Person\u0026gt; tmp = waitByFloor.get(elevator.getCurrFloor()); if (this.reqDirection == Dir.UP) { tmp.sort((a, b) -\u0026gt; b.getTo() - a.getTo()); } else if (this.reqDirection == Dir.DOWN) { tmp.sort(Comparator.comparingInt(Person::getTo)); } else { tmp.sort(Comparator.comparingInt(a -\u0026gt; abs(a.getTo() - 6))); } // ... } } 二、多部电梯分发策略\r从 hw6 开始，输入不再指定电梯来运送乘客，所以需要设计请求的分发策略。我简单分析如下：\n1. 平均分配\r实现简单，index = index % 6 + 1; 即可； 性能方面，可作为 baseline，可以认为性能不超过平均分配的分配策略不值得实现（当然能否找到这样的策略另说） 2. 随机分配\r实现简单，index = new Random().nextInt(6) + 1;即可； 性能方面，显然上限很高下限也很低，平均一下应该和平均分配是一样的，个人认为不太有必要采用。 3. 构造电梯评价系统\r一种想法是可以直接地构造一些评价指标，如以现有载客量、当前楼层、当前方向等等因素作为输入，以综合得分作为输出，得分最高的电梯作为分配对象。也就是说需求分配问题可以建立一个评价模型，可以通过实验来调整各个输入的权重，整体调参过程感觉可以类别训练一个多层感知机。\n优点：训练一次，无限次复用权重，在选择时进行一些简单的计算即可得出选择目标，不太可能CTLE，而且表现理论优于平均分配 缺点：训练困难，在没有一些加速方法的情况下，一个权重组得到一个结果就要几分钟，更何况需要对训练集进行计算；就算采用多进程等方法，整体的训练时间恐怕也是难以忍受的；而且根据输入的选择和模型的选择，能否收敛、能否防止过拟合还要打一个问号。 私以为实现这种ANN-like无异于炫技，要是真有人实现出来并且效果很好，苯人会膜拜+想知道怎么加速训练时间的，求求你教教我.jpg\n4. 影子电梯\r前人智慧的结晶！按照我的理解，影子电梯意思是为每个电梯复制一份虚拟的电梯并将请求发给它，让其模拟至完成此请求/完成所有请求，根据运行结果选择最优的电梯（这个概念让我想到两个形象，一个是伸出食指的奇异博士，一个是拿到封印卷轴后学会多重影分身之术的漩涡鸣人）。\n实现而言，需要实现电梯相关类的“影子化”，不仅涉及行为逻辑的改变，也要注意深克隆的问题，以防影子电梯对原电梯产生副作用。具体而言，我创建了 toShadow 方法，实现了 ShadowElevator 子类，为诸多实体类实现了 Serializable 接口、编写 utils.SerialClone 以实现深克隆。\n优点：简单粗暴，基本不用实现新的逻辑，为每部可选电梯新开线程执行并获得执行结果即可。当然这部分的实现难度也基本取决于已有架构的性能、解耦做的好不好；适应多种优化目标，无论你是想做总运行时间、响应时间、总功耗的单目标优化，还是综合的多目标优化，使用影子电梯进行模拟都足够支持你的想法。 缺点：这个方面更像多重影分身之术，它理论上需要的 cpu 时间相当于多出了一倍的电梯，而且注意是每次有新请求都要重新进行一次计算， cpu 时间开销大。 5. 影子电梯使用指南\r还记得我在上一节中把影子电梯比喻成多重影分身之术，而我们都知道只靠分身是难以构成什么有效的攻击手段的，所以这一章相当于探讨如何搓螺旋丸。\n假设我们有 n 部电梯，从上一节的定义出发，我们会新开线程进行模拟 n 种选择方向。实际上，我们应该新开 2n 个线程，对每部电梯分别模拟接收新请求和不接受新请求，构成 n 种选择分支（1部电梯接收，n - 1 部照旧，照旧运行的电梯无需重复模拟）。\n电梯\\运行情况 电梯1 电梯2 电梯3 电梯4 电梯5 电梯6 分发该请求 $ A_1 $ $ A_2 $ $ A_3 $ $ A_4 $ $ A_5 $ $ A_6 $ 不分发该请求 $ B_1 $ $ B_2 $ $ B_3 $ $ B_4 $ $ B_5 $ $ B_6 $ 对选择方向 $ S_i $，取 $ A_i $ 和所有 $ B_j, j \\neq i$ 即可。\n(1) 自我竞争影子电梯\r话都说到这一步了，其实没必要还只想着单目标优化了，可以面向性能分计算公式进行优化，同时考虑三个指标（毕竟我们只需要在模拟的途中进行一下简单的计算），即 $T_{run},MT,W$。下面我将给出我的实现思路。\n截止：使用 DumbQueue 模拟新请求为最后一个请求； 模拟：电梯运行途中计算各性能指标，运行结束后查询性能指标情况，得到当前选择分支下 $T_{run},MT,W$ 的值； 转换：由于我们实际拥有 n 部电梯的模拟运行结果，实际上可以用这些模拟结果计算 $x_{avg},x_{min},x_{max},base_{min},base_{max}$ 。对于折算函数，在 $base_{min},base_{max}$ 不变的情况下可以将其近似为一个分段一元一次函数 $r\u0026rsquo;(x)$，以减少幂函数和浮点数计算的开销； 选择：为三个指标赋予权重，初始可以复用课程组 334 的权重，得到得分之后选择得分最高的电梯分配请求。 这种实现完全面向性能分，用自己的架构作为模拟竞争的对手，贪心地获得每一次的决策。\n(2) 调参\r这种实现的调参只用调整三个数，即三个指标的权重。这里可以参考第一次作业的强测结果，如果你的单部电梯策略倾向于节约用电量，则可以适当提高响应时间和运行时间的权重；如果单部电梯策略倾向于减少响应时间，也可以进行类似的调整，总体而言调参是有方向的，是 few-shot 甚至 zero-shot 即可完成的。本人尝试了7种只含0或1的参数、一些特殊意义的参数如 985、211、411，其实很快就得到了想要的效果。\n(3) 优化\r我们真的需要 2n 个新线程吗？：不是的。实际上我们可以利用记忆化搜索的思想，第一次需要新开 2n 个线程，第二次开始只需要新开 n 个线程：在得到要选的电梯后，我们其实同时得到了在该选择下在三个性能分维度上电梯的表现，可以把运算结果返回给真实的电梯，并随着真实电梯运行对运行时间、耗电量做减法（与影子电梯期间的加法相反），在下一次影子化的时候把运行结果作为未收到新请求的电梯的运行结果即可。 关于 $ ET $ ：这个值的计算打表或许更好，毕竟涉及到浮点数计算。 我每次只开 n 个线程模拟接受新请求，用其一部电梯的性能表现来代替其对应选择分支的情况不行吗？：可以，我也做了对应的实验，但是效果不太好。 架构设计分析\r三次作业架构设计的逐步变化和未来扩展能力；识别出三次作业稳定的内容和易变的内容，并加以分析\n以下是 hw5、hw6 的类图\n以下是 hw7 新增部分的类图\n在本单元的开发中我始终注意架构的可拓展性和解耦，所以本单元的架构图还是比较理想的。主要得益于以下几点：\n实现了物理电梯和电梯控制器的分离，这样的解耦有助于对它们进行独立地扩展和优化 CalPerf 和 Controller 接口为统计性能和控制电梯提供了扩展点。考虑到可能的未来扩展，如要支持新的电梯类型，可以通过实现这些接口来完成整体架构的设计。 遵循单一职责原则，比如分离了 InputThread 和 Dispatcher，让 InputThread 只负责监听输入并将其转换为请求、及时响应重置请求，让 Dispatcher 负责对请求进行分发。 总的而言，我在 hw5 进行了较为充分的架构设计，在 hw6 实现了影子电梯，在 hw7 对双轿厢电梯进行了拓展，本单元的代码量还是不少的，最后 hw7 共计有 2k 行代码，但是并没有进行巨大的重构，在开发过程中我也考虑了编写接口并实现的必要性，这为我的开发流畅度提供了不小的帮助。\n稳定的内容\r物理电梯模型：Elevator 类，如 up(), down(), open(), close(), inPerson(), outPerson() 等，这些是电梯控制的基本操作，不太可能频繁变化。（如果像之前的作业一样出横向电梯/摆渡车，那也算是同一种物理电梯模型） 接口：CalPerf 和 Controller 接口定义了性能统计和电梯控制的基本方法，这些接口相对稳定，因为它们提供了系统的基本功能；由于始终有实现深克隆的需求，实现 Serializable 接口也算稳定的内容。 自定义数据结构：Person 类作为基础数据结构，考虑了乘客的基本信息，不容易改变。 线程模型：本单元的主题，我早早地想到应该有三类线程，新加入的双轿厢电梯也属于第三类线程，是符合开闭原则的开发。 易变的内容\r新的请求类型：hw6、hw7 分别提供了一次新的请求类型，这应该也是课程组进行迭代的切入点，受其影响 InputThread 每次都要新开一个分支进行判断处理。 请求队列管理：RequestQueue 的实现细节容易受影响而需要改变，如加入重置请求后无法认为请求发出去之后就一定会被完成，还要考虑电梯无法一次送达、需要进行再分配，使用统计未到达人数的方法来判断是否已经处理完所以请求。 电梯行为控制：Scheduler 的实现细节也容易受到影响，如 hw6 中加入的 RECEIVE 要求。 为什么要分析稳定的内容和易变的内容呢，不是每次作业都要进行迭代开发吗？我一开始是带着这样的疑问开始写博客的。按照我现在的理解，其实是希望我们的架构能够向高内聚低耦合的方向靠拢，如果架构耦合度足够低，那么每次开发都可以遵循开闭原则，只对新增的内容进行增量开发而无需修改原有的逻辑。就这个角度而言，稳定的内容应该尽量多，而易变的内容应该尽量少，以提高可维护性和可扩展性。这样看来，我的架构还有可以改进的地方。\n如何实现双轿厢的两个轿厢不碰撞\r其实这不就是临界资源嘛，参考 jhz 同学和操作系统中介绍的做法，我实现了 TheFloor 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class TheFloor implements Serializable { private static final long serialVersionUID = 23894756L; private volatile boolean occupied; // ... public TheFloor() { this.occupied = false; } public synchronized void get() { while (occupied) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } occupied = true; notifyAll(); } public synchronized void release() { occupied = false; notifyAll(); } // ... } 在创建双轿厢电梯的两个轿厢分别的线程时，我会把同一个 TheFloor 对象传递给它们，在移动到换乘楼层时会先尝试 get()，在离开楼层时会进行 release()。当然，为了避免其中一部电梯送完乘客之后在换乘楼层等待请求导致不释放该临界资源，单个轿厢的运行逻辑中要进行相应的处理，在此不赘述了。\nBUG \u0026amp; DEBUG\r本单元的BUG基本来源于高强度的并发（因为使用自己写的多进程评测机进行压力测试），主要是以下两种：\n竞态条件：释义为运行的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。这种BUG我觉得大部分同学都曾出现过，毕竟一开始学的是面向过程编程，对指令的执行顺序其实有不少潜意识里的假设，期待着他们会顺序执行。比如 RECEIVE 输出要求的加入，其实潜在地要求了我们关注运行的先后顺序。我的解决方法是利用高压力的评测机首先尝试复现输出出错的地方（毕竟竞态条件不总是会产生问题，需要不恰当的执行时序，这就是并发啊，你们有没有这样的并发啊），对出错的地方尝试利用一些布尔型变量规定执行顺序。比如我的程序出现过不结束的情况，后面debug结束才意识到应该是该类错误而不是死锁。 死锁：主要原因来自线程持有一个或多个资源，但同时等待其他线程持有的资源。这种情况需要使用调试或者 jconsole 之类的工具来发现死锁，当然也可以使用大 print 调试法。找到问题之后我基本会尝试对代码进行重新排列，以求避免在持有一个锁的情况下去请求另一个锁。不过印象中好像这次作业没怎么碰到死锁？ 初次接触多线程，即使是简单的需求，写出bug也是难免的。我的经验就是先进行高压力的运行、对出错的输入输出使用瞪眼法和print调试法，再尝试利用理论知识进行解决。\n心得体会\r线程安全的bug啊，能一下子de出来都是神人了。还好一开始我就打算写评测机，为了追求快点完成评测发掘了可以多进程评测，帮助我触发了不少线程安全的bug。到头来感觉最需要注意的不是死锁而是竞态条件，也算是 OO 相比面向过程的一个特色了吧。清明在宿舍写了三天代码，bug没修完出门拿外卖又要坐电梯，看到电梯感觉人生都完蛋了。 层次化设计是我这单元挺注意的一个方向，也算是从第一单元中学到了东西。进行解耦、设计整体框架、履行单一职责，都有助于项目的顺利开发。包括面对 hw6 的新需求时，我选择先实现 RESET 的支持而非实现影子电梯，也算是先从大框架入手、再注重局部的提升，这种考虑也为我 debug 时减少了一些怀疑的方向。 感觉这单元相比往届的改动还算挺好的，比如我提到过的 RECEIVE 与竞态条件、换乘楼层与临界资源，可以说让电梯和多线程结合地更好了。支持限制自由竞争，不过影子电梯就别限制了吧，希望 CPU 时间可以放宽点，毕竟没有那么多时间进行剪枝优化。 真的要写评测机啊，在写正确性判断的时候可以对需求有更深的理解，在加快评测的时候可以发现更多的bug，可以说我完全是边修作业的bug边修评测机的bug，投入时间也很多，不过结果还算理想，所以尽兴就好吧！ ","date":"2024-09-02T00:00:00Z","permalink":"http://localhost:1313/p/oo-u2-doc/","title":"OO | Unit 2"},{"content":"第一单元博客\r一、整体设计的量化分析\r1、类图和优缺点分析\r入口类：MainClass 计算类：Poly、Mono 解析主体类：Lexer、Parser 工具类：处理自定义函数定义和调用的 FuncExpander、从字符串分析成分并用于优化的 Recognizer 文法成员类：Expr、Term、Variable、Number，没有指数函数是因为偷懒直接调用计算类构建了 优点：层次清晰、方法简明，使用解析主体类和文法成员类配合完成递归下降解析，计算类负责存储输出表达式的组分和边解析边化简 缺点：两个计算类耦合程度较高（见后续分析），可以单独提取一个计算器功能的类；对包的理解不够深刻，基本是看心情和直觉决定放在 expr 文件夹内与否\n2、代码规模分析\r使用 Statistic 协助分析\n可以发现文法成员类和入口类的代码行数都很少，这是因为他们的属性、方法个数都很少，方法规模基本转移到调用的类中了\nParser 类实现了使用循环语句解析表达式层次、使用分支语句覆盖多种因子类别的功能； Poly 类和 Mono 类需要实现取负、加法、乘法、乘方、合并等计算、满足数据结构要求而重写的 equals 和 hashCode 方法、用于表达式输出而重写的 toString 方法、针对业务需求写了多种构造方法等。 3、代码复杂度分析\r使用 Metrics 协助分析，包括分析各指标中前6复杂的典型方法\n认知复杂度 CogC：简单来说就是衡量方法的理解难度，与控制流结构的复杂程度有关，注意与圈复杂度区分 表达式输出优化相关：Mono.toString、Poly.asString、Recognizer.isExponent、Mono.canBeTeared 都属于输出化简后表达式导致的理解难度，要在考虑文法的同时优化总长度并进行输出，势必要引入一些特殊规则的判断，如特定的0能不能不输出、特定的系数1能不能不输出、指数函数能否变化为带幂次的形式而减少括号、输出表达式的时候有没有系数为正的单项式可以提前输出，个人认为在保证正确性和性能分的前提下增加认知复杂度是情有可原的； 计算相关 Poly.powerTrans：为了统一形式和实现“边解析边化简”，我选择实现这个方法以计算对应多项式的幂次结果。方法中包含了幂次为0的预剪枝、主体进行指定次数（小于等于8次）的乘法，故包含了3层循环。这里可以提取一个乘法方法； 解析相关 Parser.parseFactor：由因子多样性导致有多个 if-else 分支。 基本复杂度 ev(G)：衡量程序非结构化程度 字符串相关：后四种都与字符串逐个解析有关，字符串肯定会有很多判断语句不可避免； Mono.equals：重写中涉及了较多预剪枝，尽量不碰到指数函数因子部分的相等判断，个人认为是值得的。 模块设计复杂度 iv(G) 和圈复杂度 v(G)：主体都是圈复杂度中对于独立路径条数的计算，结果差不多故放在一起 这些方法在上文已经分析过了，不再赘述 类复杂度分析： 加权复杂度较高的 Poly 类和 Mono 类：在代码规模分析中其实可以预测到这里表现较差了，优化空间个人认为只剩下把计算相关的功能单独提一个类出来，但这并不能改良计算本身的复杂性； 平均操作复杂度较高的 Recognizer类：这个类表现较差倒是意料之外情理之中，我猜主要是由于依据文法规则逐字解析字符串和 Recognizer.isNumber 方法受类中另外两个方法调用导致。 二、从迭代看架构\r1、第一次作业架构\r问题重述：读入一个单变量表达式，输出变形后不含括号的等价表达式，在保证正确的前提下使得输出表达式尽量短。\n预处理方法：经过分析发现去除空白字符是性价比最高的预处理方法，在 Lexer 的构造方法中直接实现了；讨论和观察中注意到大部分同学还对正负号进行了预处理，但我认为遵循形式化表述并在适当的地方使用 parseSign 方法即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Parser.java // 使用true代表正号，false代表负号 public Boolean parseSign() { if (lexer.peek().equals(\u0026#34;+\u0026#34;)) { lexer.next(); return true; } else if (lexer.peek().equals(\u0026#34;-\u0026#34;)) { lexer.next(); return false; } else { return true; } } 表达式的读入和解析： 从形式化表述可以发现表达式具有明显的树状结构，结合前置知识和对应练习自然地想到利用递归下降的思想进行解析，因此程序复用了练习中 advance 的递归下降结构。在递归下降的解析过程中，重要的是改写指导书给出的形式化表述，比如可以写成右递归或者带循环的形式。笔者采用了带循环的形式，改写如下（不考虑空白项）： 表达式：[加减] 项 {加减 项} 项：[加减] 因子 {'*' 因子} 因子：'x' [空白项 指数] | [加减] 允许前导零的整数 | '(' 表达式 ')' [空白项 指数] \u0026hellip; 由此引出 Parser 类中的五个用于解析组分的方法：parseExpr() 、 parseTerm() 、 parseFactor() 、 parseSign() 、 parseExponent() 。 边建树边合并： 这里其实也呼应了上一段中使用 HashMap 来表示语法树的用意，我在完成项目的途中始终想的是树的结构，但实现看不到典型的结点等概念，因为在各对象构建语法树的过程中都可以将语法树保持为深度为 1 的多项式树。这个想法只需要 Expr 和 Term 类中的方法实现边建树边合并，即 Expr 新增项时实现加法， Term 新增因子时实现乘法。 各组分的存储结构： 考虑到使用递归下降对表达式进行解析，解析过程中的表达式、项、因子其实都是整棵抽象语法树的子树，所以对于各个语法对象其实都可以使用一个树结构进行存储。具体到表达式这个问题上，通过分析一定是叶子节点的变量因子和常数因子可以发现，第一次作业中的表达式总等价于一个多项式，这也是我们想要的 不含括号的等价表达式 。要表示一个多项式，其实只需要使用 HashMap 来存储次数和系数的键值对，就可以利用其一直完成到最后的表达式输出。所以可以构建一个接口 SynComp （文法组分），其中提供 getPoly() 等方法。 可以看到这里的4. 组分存储结构导致为了hw2势必要进行重构，放一个生前的类图吧\n这次作业（hw1）的架构可以看出，每个 Factor 的实现中都有一个 poly 属性，实现对应组分的存储，仅考虑了幂函数的次数和系数，这样的可拓展性是相当差的；而且将 powerTrans 作为接口中的方法要求，实际上这个方法只有 Expr 一个类有用法，违反了SOLID原则中的接口隔离原则。\n2、第二、三次作业架构\r重构后架构设计\r哎，重构： 相比hw1增加了指数函数和自定义函数的部分，个人认为指数函数提升了对自定义类的要求，毕竟如果hw1像苯人一样 使用 HashMap 来存储次数和系数的键值对\n而不考虑可拓展性的话，就要付出惨痛的重构代价。就本次作业而言，一个必然满足正确性要求的输出形式为 $ Q(x)=\\sum^{i} a_i*x^{b_i}*exp(c_i) $ 、$ c_i=Q(x\u0026rsquo;) $。个人也建议从输出形式倒推自定义类的设计，这样不仅利于最后的输出，也利于在使用递归下降等方法解析表达式的时候进行边建树边合并。言归正传，本次作业我设计了 Mono 类和 Poly 类作为“基类”，原有的 语法成分类 利用这两个类进行计算和合并等操作。\n指数函数： 基于 Mono 类，要实现指数函数的解析、运算和存储都不算难事。\n自定义函数：\n已有的架构无法完全处理自定义函数，势必是要创建一个新的类进行解析的。这个类要实现对自定义函数声明/定义的解析，包括存储形参、函数表达式。 为了保证逻辑的统一性，解析自定义函数的方法应该被解析因子的方法调用，同样地返回一个 Factor 或 Poly 类的值。 如果能保证处理好本次作业除自定义函数的部分，一个简单的处理自定义函数调用的方法是将函数表达式中的形参换为实参，再调用 Parser 类进行解析。这样能提高代码的复用率，满足上述的架构要求，耦合度也相对较低。 微分因子： 对多项式 Poly 类使用加法法则，对扩展单项式 Mono 类使用乘法法则即可。\n重构后实现要点\r自定义类的深克隆问题： 注意到在表达式$Q(x)=\\sum^{i} a_i*x^{b_i}*exp(c_i)$ 中， $c_{i}$ 代表的是因子，在进行所有必要的展开之后，它最坏是一个表达式。因此你可能会在 Poly 类中使用容器存储 Mono 对象，又在 Mono 类中使用 Poly 对象表示指数函数的指数。务必注意检查是否使用了深克隆而非浅克隆，因为在解析和化简的过程中难免对这些对象进行运算，对克隆的疏忽容易导致灾难性的后果。\n合并同类项的双刃剑——重写equals与hashcode方法： 要进行同类项的合并，我们需要比较 Mono 对象的 x 幂次和指数内容，一个直接的想法是重写equals与hashcode方法从而能够直接比较两个对象是否相等。需要注意的是考虑到上一个问题中涉及的 Mono 类和 Poly 类的嵌套，这个地方的重写需要充分的考虑，在 Poly 类中利用 HashMap 结构完成各 Mono 对象的相等判断，在 Mono 类中注意对指数函数中指数项的相等判断。\n指数函数的输出： 注意指数函数的指数是因子，在输出的时候应该呈现因子，不能直接输出表达式；在化简时也可以考虑将表达式因子尽可能降到常数因子和幂函数等形式，有助于提高性能分。\n自定义函数相关： 形参替换的时候如果不作处理，容易改变exp中的x，已有同学在讨论区提出解决方法；将实参代入形参的时候应该使用括号括起实参，否则可能导致表达式的运算优先级发生改变。\n3、重构体验\r几乎是在一看到第二次作业要求时就意识到了重构的必要性，其实主要的时间都在思考能不能避免 Mono 类和 Poly 类的反复嵌套，最终还是接受了这种实现。主要的心路历程是空想时的痛苦和怀疑、战战兢兢地写代码害怕无法实现、和最后发现“诶，好像没事”。虽然反复嵌套比较难看、耦合程度较高，但是在题目数据范围内是比较快速有效的实现了。\n4、迭代场景畅想\r增加新的函数因子：比如类似往届引入三角函数，这个正确性处理上和指数函数思路一样，为 Mono 类新加属性即可，并且以此为基础审阅所有相关计算方法是否正确 增加变量类型：如果从单变量扩展到多变量，也是需要增加新属性，检查相关方法 增加变换方法：如增加积分，新增方法返回指定参数下的计算结果即可，虽然能不能算出来是另外一个问题了 整体来说，只要不跳出表达式化简的这个大目标，现有的架构对新需求的可扩展性表现较好，毕竟我处理第三次作业只需要更新不到50行代码。\n三、bug分析\r就课程组评测而言，印象中只在hw2的重构过程中提交的一次中测发现了bug，主要是因为重构写的急导致字符串替换时出现的问题（将exp替换为E后忘记替换回来），发现后很快解决了。\n查看Git日志后发现，hw1主要是对样例debug就结束了，因为没有别的方法找bug所以搓了评测机，开启了unit1的不归路（？\nhw2经历了大重构，多数的bug也在这里发现，从Git日志中可以看出主要的bug似乎还是从自己的评测机中测出来的，包括没有遵循文法导致exp内部的表达式因子没有加括号等等\n如果把开发过程中发现的bug也算入在内的话，我认为得通过开始写代码前写个todolist来解决，这样可以避免陷入局部忘记整体。\n互测阶段有一个自己测出自己的bug，当真有点汗流浃背：\n1 2 3 4 5 3 g(z)=exp(exp(exp(exp(z)))) f(y)=exp(exp(exp(exp(g(y))))) h(x)=exp(exp(exp(exp(f(x))))) h(h(h(exp(exp(exp(exp(x^8))))))) 这个形式的数据会导致我和互测房间中的多人产生 TLE，我使用了 JProfiler 进行性能分析，发现是在输出过程中递归调用了太多次的 toString 方法，随着 exp 的嵌套运行时间应该是指数级提升。经过修改一些代码语句来规避对 toString 的调用即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Poly.java public String asString(boolean asFactor) { StringBuilder sb = new StringBuilder(); boolean first = true; Mono firstMono = firstPositive(); // Modified here // if (firstMono != null \u0026amp;\u0026amp; !firstMono.toString().isEmpty()) { if (firstMono != null) { sb.append(firstMono); first = false; } for (Mono mono: this.mos.keySet()) { // Modified here // if (mono.toString().isEmpty() || mono.equals(firstMono)) { if (mono.equals(firstMono) || mono.toString().isEmpty()) { continue; } if (!first \u0026amp;\u0026amp; !mono.isNegative()) { sb.append(\u0026#34;+\u0026#34;); } sb.append(mono); first = false; } if (sb.length() == 0) { sb.append(\u0026#34;0\u0026#34;); } if (asFactor \u0026amp;\u0026amp; !canBeSimplified(sb.toString())) { sb.insert(0, \u0026#39;(\u0026#39;); sb.append(\u0026#39;)\u0026#39;); } return sb.toString(); } 两处修改分别为避免冗余的并判断和提前短路或判断，前者似乎不是什么可以复用的设计技巧，毕竟我更偏向于保留一些冗余的保险设计；后者倒是在发现时可以调整一下，毕竟不影响正确性。\n代码行数来讲两者无差异，圈复杂度倒是由于if条件的简化下降了1，这应该属于通过减少无效判断来降低复杂度。此外，要降低方法的复杂度，主要是要遵守单一职责原则、对函数进行拆分和重构。通过查阅网上的资料，我发现还有一些常用的方法可以降低方法的复杂度，包括使用卫语句替换嵌套 if-else 语句、减少 return 语句的使用、减少使用控制标记变量等方法，但我认为重要的是在方法复杂度和方法功能中进行取舍，要避免写出又臭又长的代码，也不能为了追求低复杂度而过分拆分方法。\n四、hack分析\r测试策略：自动手动相结合。\n1、评测机\r开源链接\n首先是hw1借助学长提供的评测机架构，利用python的sympy等库，基本实现了自动化生成数据、正确性判定和hack数据导出，也实现了cost计算。 hw2时间紧张，但还是实现了指数函数和自定义函数的生成，判断正确性方面考虑到sympy库的性能有点差，最终使用了对拍的方法，事实证明面对OO互测这样的场景对拍是一个简单有效的方法，就算在互测前也可以和友人对拍；而且sympy只能实现对答案正确性的部分判断，即它能接受exp(-x)等不符合文法的化简结果，面对这种情况我的解决方法是确保自己的程序（或者某个别人的程序）对文法的读取非常严格，将其作为文法检查器，对别人输出的表达式进行读入解析再输出，这种做法也相当有效。 评测机加入了对 TLE 的考虑，其实在hw2已经出现了有几组数据运行时间过长的情况，但考虑到生成输入、正确性判断使用了sympy等因素，我并没有深究其中原因。在hw3中尝试利用生成概率控制表达式的复杂度，并加入了程序只能运行10s的限制，由此提供了对TLE的支持。 2、手动测试\r手动测试的流程发生在自动评测之后，毕竟这就是自动评测机的意义。对于已经有报错数据的程序，我会尝试查找它们出错的原因，并根据代码情况考虑是否会有相关的bug产生；对于没有报错数据的程序，我会更细致地阅读它们的内容，综合一次作业中的典型错误进行排查。\n3、结合实际情况的分析\rhw1： 相当和平，我的房间没人中刀，这个时候怀疑过评测机是不是写错了 hw2： 惨烈的战役，自动化测试中发现有的程序输出了类似 exp(-x) 的内容，在手动构造测试样例的时候发现了还有同学会将负数系数作为幂次提出，这也违反了文法的要求，所以战果是产生了一刀四爆 =)；此外自动测试还发现一个同学的报错有 substring 访问越界和 BigInteger divide by zero 的问题，第一个问题如果别的程序有应该早能自动测试查出来了，而第二个问题是因为该同学的程序实现了除法，似乎是为了优化相关的工作，而其他同学基本没有考虑到使用公因子提取进行优化，故这个问题其他同学也不存在。这次互测是究极大乱斗，我hack出的每个bug应该都和别的同学共享了战果，所以虽然刀中了5个人应该得分也不算高。 hw3： 一家独大的战役，这次使用评测机测出了2个 TLE、一个 StackOverflowError、一个 WA。大家的 TLE基本都是架构中反复调用次数太多导致的，StackOverflowError 是反复调用导致超时之前先爆栈了，很难说谁的重构难度比较大。WA 的同学似乎是在同类项合并上栽了跟头，居然在hw2中没有被测出来（）本来做到这里感觉已经无可hack了，但在友人的提示下发现多层嵌套的 exp() 也能导致超时（之前评测机测出的 TLE 是幂次运算时间太久导致的），这个样例让我的程序也被攻破，只能说还好同房没有发现这个数据。其实我在hw2便注意到了 exp 对cost的影响很小，但当时并没有想到借此构造极端数据，因为 exp() 本身就有5个字符之长了，而且hw2中函数不支持嵌套；hw3中开放了函数嵌套提供了对架构简洁性进行测试的可能，导致可以在相当符合规则的程度上进行hack。通过构造一个极端数据点，本次互测又成功多刀一人。这次互测刀中了5个人，独享了4个人的经验=)。 五、优化分析\r1、优化内容\rMono 层：\n如果系数为0返回空字符串，让 Poly 层决定接下来的处理。 系数不为0时考虑按照 系数 - 带次数的x - 指数函数 的顺序进行输出。 如果次数不为0/指数函数部分存在 且 系数绝对值为1，可以省略系数。 e.g. 1*x -\u0026gt; x 如果次数为0不输出 x 部分；如果次数为1不输出 ^n 部分。 对指数函数部分，利用子方法 canBeTeared 来判断能否将指数函数进一步化简。 e.g. exp((3*x^4)) -\u0026gt; exp(x^4)^3 利用标识变量决定要不要输出 * 来连接各部分。 Poly层：\n正项提前输出。 e.g. -x+1 -\u0026gt; 1-x 确保各单项式之间仅用一个正号或符号连接。 如果作为因子输出，利用子方法 canBeSimplified 来判断是否要作为表达式因子而加括号。e.g. exp((3)) -\u0026gt; exp(3) 考虑到个人能力、开发耗时和程序耗时，我没有选择对 Poly层进行更多的化简，包括提取公因子、拆分exp等方法。\n2、优化分析\r感觉这里有点像开放封闭原则，即就算要优化输出表达式的长度，也不应该影响输出表达式的正确性。我的代码保持了简洁性和正确性，如果要按上文进行提取公因子、拆分exp的优化，确实可能对这两者产生危害，所以不妨在要进行进一步优化的前提下思考解决方案。这里应该贯彻开放封闭原则，保护已经有简洁性和正确性的代码，新开方法进行优化。当然这一定程度上会和程序耗时产生冲突。 比如，公因子提取肯定是要发生在一次输出之前的，可以考虑对 Poly 类新增边合并边计算gcd的功能，让字符串输出之前可以通过访问属性来优化输出，这也能降低程序的耦合程度；关于如何拆分exp也应该随着对象内容的更新而实时更新，让 toString 方法直接调用而非计算。\n六、心得体会\r及时拆分方法，常常跳出局部看全局。 Unit1整体对层次化的要求感觉跟OOPre差不多，但毕竟经历了OOPre的磨练，感觉Unit1整体的代码分布很和谐，看着重构完不错的架构感觉很爽，当然重构是痛苦的。 前两周OO花的时间实在是太多了，很奇怪的难度曲线，我是完全独立完成的hw1，很难想象一个初学者如何能在不参考学长博客的情况下写出高拓展性的架构，hw2发现我所想和学长架构差不多的时候是感到庆幸的。 多多考虑可拓展性，我的程序在第一次作业支持了嵌套括号，第二次作业支持了自定义函数嵌套，多做些不过分的考虑。 伟大的评测机，写评测机的过程也对作业本身有加深理解的作用。感谢学长提供的第一次作业评测机架构，和从hw2开始和我一起开发评测机的yez同学。希望大家多多开源评测机交流！ 七、方向建议\r第一单元的性能分可以考虑计算运行时长等，占比较小，希望多测几次预防服务器波动 缩短互测hack间隔，要拿满基础分至少要花2.5h（A房） ","date":"2024-09-01T00:00:00Z","permalink":"http://localhost:1313/p/oo-u1-doc/","title":"OO | Unit 1"},{"content":"Lab 6\r一、思考题\rThinking 6.1\r示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { // ... switch(fork()) { case -1: break; case 0: // 子进程 close(fildes[0]); // 关闭读端 write(fildes[1], \u0026#34;Hello world\\n\u0026#34;, 12); close(fildes[1]); exit(EXIT_SUCCESS); default: close(fildes[1]); read(fildes[0], buf, 100); printf(\u0026#34;read: %s\u0026#34;, buf); close(fildes[0]); exit(EXIT_SUCCESS); } } Thinking 6.2\r上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？\n在 Exercise 6.3 的修改之前，dup 的实现是先将文件描述符进行复制，再复制文件的内容，这样 pageref(fd) 就会先于 pageref(pipe) 进行更新，如果在文件描述符复制结束后立刻发生进程切换转到父进程运行，而父进程调用 pipe_is_closed(p[1])，会得出 pageref(pipe) == pageref(p[1]) 的结论，误以为管道已经关闭。\nThinking 6.3\r阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。\n在 MOS 操作系统中，系统调用函数以 syscall_ 开头，具体调用链如图：\n其中 msyscall 使用了汇编指令 syscall，该指令会屏蔽中断进入内核态，由此实现系统调用的原子性。\nThinking 6.4\r仔细阅读上面这段话，并思考下列问题\n按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。 我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。 可以解决上述场景的进程竞争问题，应该先解除 pipe 的映射，再解除 fd 的映射，这样即使在 unmap 的间隙发生中断，仍然有 pageref(pipe) \u0026gt; pageref(fd)，不破坏管道开关状态判断的正确性。 会出现类似的问题，分析见 Thinking 6.2，顺序不当时会出现 page_ref(fd) == page_ref(pipe)、造成读端/写端已满的假象，从而破坏判断的正确性。 Thinking 6.5\r思考以下三个问题。\n认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。 回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。 在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和 filesize ，我们在 Note 1.3.4 中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper() 函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？ 打开文件 open(const char *path, int mode) -\u0026gt; fsipc_open(const char *path, u_int omode, struct Fd *fd) -\u0026gt; fsipc(u_int type, void *fsreq, void *dstva, u_int *perm)，在 fsipc 函数中向文件系统服务进程发出请求并接受返回的消息，而文件系统服务进程调用 file_open 对文件进行打开操作并通过进程间通信告知原进程。 读取并加载 ELF 文件由 kern/env.c 文件中的 load_icode 函数实现，包括解析 ELF 头、加载程序段、设置入口点。 elf_load_seg()：处理到 bss 段的时候，该函数会调用 map_page (此处为 load_icode_mapper)并设置参数 src 为 NULL，对应 load_icode_mapper 中的处理： 先在 page_alloc 中将对应内容置 0，然后在 src == NULL 时跳过 memcpy 操作。 Thinking 6.6\r通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。\n1 2 3 4 5 6 7 8 9 10 11 // user/init.c main() // ... // stdin should be 0, because no file descriptors are open yet if ((r = opencons()) != 0) { user_panic(\u0026#34;opencons: %d\u0026#34;, r); } // stdout if ((r = dup(0, 1)) \u0026lt; 0) { user_panic(\u0026#34;dup: %d\u0026#34;, r); } // ... Thinking 6.7\r在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子 shell，然后子 shell 去执行这条命令。 据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // user/sh.c for (;;) { if (interactive) { printf(\u0026#34;\\n$ \u0026#34;); } readline(buf, sizeof buf); if (buf[0] == \u0026#39;#\u0026#39;) { // here continue; } if (echocmds) { printf(\u0026#34;# %s\\n\u0026#34;, buf); } if ((r = fork()) \u0026lt; 0) { user_panic(\u0026#34;fork: %d\u0026#34;, r); } if (r == 0) { runcmd(buf); exit(); } else { wait(r); } } 在此循环中，除了开头为 # 的注释，都需要 fork 一个子 shell 来处理输入的命令，故为外部命令。\n在Linux操作系统中，cd 命令是一个非常常用的指令，用于改变当前工作目录。如果将 cd 设定为外部指令，每次执行时都会导致系统调用 fork 来生成一个新的子进程。这种做法在频繁使用 cd 命令的情况下，会显著降低系统效率，因为它涉及到多次不必要的进程创建和资源消耗。\n为了提高操作系统的性能，将 cd 命令实现为内部指令是一种更优的选择。作为内部指令，cd 可以直接在当前进程的上下文中执行，无需创建额外的子进程。这种方法可以减少系统调用的开销，提高命令执行的效率，从而使得操作系统的整体性能得到提升。\nThinking 6.8\r在你的 shell 中输入命令 ls.b | cat.b \u0026gt; motd。\n请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？ 请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？ 两次 spawn，分别是由最初被 fork 出的2803进程 spawn 出了3805进程，以及3004进程 spawn 出了4006进程。 四次进程销毁，涵盖 2803、3004、3805、4006 二、实验难点\r在本次MOS操作系统实现的实验中，作为整个课程体系中最顶层的一环，它具有较高的综合性，因此难度也相应较大。我认为，实验的主要难点可以概括为以下几点：\n理解Shell程序的运行流程：需要深入掌握shell程序的各个组成部分及其相互之间的调用关系。 掌握spawn函数的实现：这涉及到对fork、ELF文件加载等之前实验知识点的深入理解与应用，需要结合Lab1至Lab5的相关内容。 整体运行流程的把握：对整个shell程序的运行逻辑有一个全面的认识。 三、实验体会\r尽管本次实验的任务量相对较小，难度也较为适中，特别是在spawn函数的理解与实现上需要投入较多的精力，但完成实验本身仅仅是开始。为了深入理解新增代码的功能和作用，还需要进一步的研究和探索。争取早日通过挑战性任务，弥补之前限时测试的遗憾。\n","date":"2024-06-26T00:00:00Z","permalink":"http://localhost:1313/p/os-lab6-doc/","title":"OS | Lab 6 文档"},{"content":"Lab 5\r一、思考题\rThinking 5.1\r如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。\n**引发的问题：**当 CPU 向外部设备写入数据时，如果数据仅存在于 Cache 中而未及时同步到设备，那么当设备自身进行数据更新时， Cache 中的数据将变得过时。这种情况下，缓存数据只有在缓存块被新数据替换时才会被写入到设备，可能导致数据不一致的问题。\n**差异：**串口设备较 IDE 磁盘读写更加频繁，使用 kseg0 读写时更容易引发数据不一致的问题。\nThinking 5.2\r查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？\n1 2 3 #define FILE_STRUCT_SIZE 256 #define BLOCK_SIZE PAGE_SIZE // 4096 #define NINDIRECT (BLOCK_SIZE / 4) // 1024 一个磁盘块中最大文件控制块数量： 4096 / 256 = 16 个 一个目录下最大文件数量： 由 NINDIRECT 定义知最大文件数量为 1024 个 单个文件最大大小： 每个文件最多指向 1024 个磁盘块，每个磁盘块的大小为 4096 = 4 KB，则所求为 1024 * 4 KB = 4 MB 对于普通的文件，其指向的磁盘块存储着文件内容，而对于目录文件来说，其指向的磁盘块存储着该目录下各个文件对应的文件控制块。\nThinking 5.3\r请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？\n1 2 #define DISKMAP 0x10000000 #define DISKMAX 0x40000000 块缓存对应的内存空间为 [DISKMAP, DISKMAP + DISKMAX)，故实验用内核支持的最大磁盘大小为 0x40000000 bytes = 1GB\nThinking 5.4\r在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。\n见注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // serv.h #define PTE_DIRTY 0x0004 // 虚拟地址脏位，注意区分 va_is_dirty 和 block_is_dirty （后调用前） #define SECT_SIZE 512 // 磁盘扇区大小，磁盘的最小组成单元 #define SECT2BLK (BLOCK_SIZE / SECT_SIZE) // 这么多个扇区构成一个磁盘块，用于读写磁盘块时辨析一个磁盘块到扇区的数目 /* 涉及到 ide_write、ide_read，记录一下使用： void test_ide_write(u_int diskno) { int data[4096]; // [1] int i; for (i = 0; i \u0026lt; 4096; i++) { data[i] = i ^ diskno; } ide_write(diskno, 4096, data, 32); } 对于参数 32 的计算，由[1]得出有 4 * 4096 个字节的数据，每个 sector 有 512 字节，4 * 4096 / 512 = 32。所以其实可以有如下宏定义： #define SECT2DATA_SIZE(n) ((n) / SECT_SIZE) */ #define DISKMAP 0x10000000 // 虚存地址空间中磁盘块起始地址 #define DISKMAX 0x40000000 // 作用在 5.3 里提过了，可以用于越界检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // fs.h #define BLOCK_SIZE PAGE_SIZE // 磁盘块大小 #define BLOCK_SIZE_BIT (BLOCK_SIZE * 8) // 按位而不是字节计数的磁盘块大小 #define MAXNAMELEN 128 // 文件名最大长度 #define MAXPATHLEN 1024 // 路径最大长度 #define NDIRECT 10 // 磁盘块直接指针数 #define NINDIRECT (BLOCK_SIZE / 4) // 磁盘块简介指针数，为了方便使用弃用了前 10 个 /* 用例见 tools/fsformat.c: create_file */ #define MAXFILESIZE (NINDIRECT * BLOCK_SIZE) // 磁盘中最大文件数量？？没太搞懂是怎么算出来的 #define FILE_STRUCT_SIZE 256 // 文件控制块变量大小 // 文件控制块的定义 struct File { char f_name[MAXNAMELEN]; uint32_t f_size; uint32_t f_type; uint32_t f_direct[NDIRECT]; uint32_t f_indirect; struct File *f_dir; // the pointer to the dir where this file is in, valid only in memory. char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; // 填充用 } __attribute__((aligned(4), packed)); #define FILE2BLK (BLOCK_SIZE / sizeof(struct File)) // 用于在磁盘块中遍历文件控制块 // File types #define FTYPE_REG 0 // Regular file #define FTYPE_DIR 1 // Directory #define FS_MAGIC 0x68286097 // Everyone\u0026#39;s favorite OS class // 超级块的定义 struct Super { uint32_t s_magic; // 魔数，grep -r s_magic 可以发现 read_super 函数中确实有对文件系统魔数的检查 uint32_t s_nblocks; // Total number of blocks on disk struct File s_root; // Root directory node }; Thinking 5.5\r在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。\n编写如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;lib.h\u0026gt; int main() { int r; int fdnum; char buf[512]; int n; if ((r = open(\u0026#34;/newmotd\u0026#34;, O_RDWR) \u0026lt; 0)) { user_panic(\u0026#34;open failed with returned value: %d\u0026#34;, r); } fdnum = r; if (fork() == 0) { n = read(fdnum, buf, 5); debugf(\u0026#34;child\u0026#39;s is %s\\n\u0026#34;, buf); } else { n = read(fdnum, buf, 5); debugf(\u0026#34;parent\u0026#39;s is %s\\n\u0026#34;, buf); } return 0; } 运行结果：\n1 2 parent\u0026#39;s is This child\u0026#39;s is is a 可以看出父子进程回共享文件描述符和定位指针。\nThinking 5.6\r请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct File { char f_name[MAXNAMELEN]; // 文件名，最大长度为 MAXNAMELEN uint32_t f_size; // 对应文件大小 uint32_t f_type; // 对应文件类型，分为普通文件和目录 uint32_t f_direct[NDIRECT]; // 文件直接指针，直接指向数据块对应位置 uint32_t f_indirect; // 文件间接指针，指向文件内容的磁盘块 struct File *f_dir; // 指向文件所在目录的指针，只有控制块已经在内存中时才有效 char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; // 填充用 } __attribute__((aligned(4), packed)); // 强制对齐 struct Fd { u_int fd_dev_id; // 外设id u_int fd_offset; // 读写的偏移量，利用其的函数包括 write()、read()、seek()，由这类功能的函数使用和维护 u_int fd_omode; // 文件打开的方式，包括 O_RDONLY O_WRONLY O_RDWR }; struct Filefd { struct Fd f_fd; // 对应文件描述符结构体 u_int f_fileid; // 文件id struct File f_file; // 对应文件控制块 }; Filefd 以及 fd 中的指向的文件控制块 File 中记录的磁盘指针对应物理实体\nThinking 5.7\r下图（文件系统服务时序图）中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。\n在操作系统的初始化过程中，init() 函数负责启动并发送 ENV_CREATE 的异步消息，包含 user_env 和 fs_serv。一旦 init() 发出这些创建消息，它会立即返回并继续执行其它初始化步骤，与此同时，fs 进程和 user 进程将独立进行各自的初始化任务。\n对于 fs 进程，它首先会执行 serv_init() 和 fs_init() 函数来完成初始化。随后，fs 进程会进入 serv() 函数，在这里它会被 ipc_receive() 调用阻塞，进入 ENV_NOT_RUNNABLE 状态，直到它接收到来自 user 进程的 ipc_send(fsreq) 消息，这个动作会唤醒 fs 进程。\n另一方面，user 进程通过 ipc_send(fsreq) 向 fs 进程发送一个同步消息，请求服务。发送消息后，user 进程自身也会进入 ENV_NOT_RUNNABLE 状态，等待 fs 进程完成服务处理。当 fs 进程处理完请求，并通过 ipc_send(dst_va) 发送回应后，user 进程被唤醒并继续执行。此后，fs 进程再次进入阻塞状态，等待下一次 user 进程的唤醒。\n二、难点分析\r文件系统屏蔽了访问外存数据的复杂性，但是在实现上也相当复杂，主要是有很多的代码文件，分布在三个主要目录：tools、fs、user/lib。然后继承上一个 lab 的理解，才能搞懂内核态的磁盘驱动和用户态读写磁盘等内容。真要说难点，基本都分散在思考题里面了，文件系统我感觉不算难，主要是体系比较庞大，需要慢慢消化。\n三、实验体会\rexam\r这一次要补充的代码也太多了，bug修复包括忘记加 file_dirty 、serve_copy 调用时应该写 directory_copy 而不是 copy_directory_contents 、手滑写成 FSREQ_OPEN 而不是 FSREQ_COPY、对字符串应该调用 strcpy 而不能直接赋值，然后对 file_dirty 理解失误填错参数、dir_alloc_file 写错目录参数。\nextra\r写了一堆代码之后没时间 debug 了。\n这就是失眠只睡了四个半小时之后的线上限时测验，不过总算结束了。\n","date":"2024-05-29T00:00:00Z","permalink":"http://localhost:1313/p/os-lab5-doc/","title":"OS | Lab 5 文档"},{"content":"Lab 4\r一、思考题\rThinking 4.1\r内核在保存现场的时候是如何避免破坏通用寄存器的？ 系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall 留下的信息吗？ 我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样的参数的？ 内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？ 在宏 SAVE_ALL 中，指令 move k0, sp 将 sp 的值复制到 k0 寄存器、然后使用 sw 指令将其保存到栈帧中，然后继续仅使用该寄存器把其他通用寄存器的值保存到栈帧中，保证了通用寄存器的值不被修改（k0 不是通用寄存器，仅供操作系统使用）。 可以。在 MIPS 寄存器使用规范中指定了寄存器 $a0-$a3 用于存放函数调用的前四个参数，而且系统陷入内核调用前后寄存器内容不会发生改变，所以可以直接得到信息。 在函数 do_syscall 中，函数从栈帧中获取了函数调用的参数，并找到对应函数进行了函数调用，保证了函数获得的参数值是用户调用 msyscall 时保存到栈帧中的参数值。 处理过程中使得栈帧中 epc 的值自增 4，并且将 sys_* 函数的返回值存入到栈帧的 $v0 寄存器中，这样的修改使得系统返回用户态时，用户程序能够从正确的位置继续运行，并且能从 $v0 寄存器中获得系统调用的返回值。 Thinking 4.2\r思考 envid2env 函数: 为什么 envid2env 中需要判断 e-\u0026gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？\n在这一步之前使用了 e = \u0026amp;envs[ENVX(envid)]; 来获得进程控制块，仅保证了 e-\u0026gt;env_id 与 envid 在低十位上相同，但没有保证完全相同，故它们的地址空间标识符（ASID）可能不同。当 envs 中的进程控制块被替换，其新的 envid 的后十位不变，但是 ASID 字段会改变，所以需要进一步判断获得的 e 是不是我们想要的进程控制块。\nThinking 4.3\r思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。\n1 2 3 4 u_int mkenvid(struct Env *e) { static u_int i = 0; return ((++i) \u0026lt;\u0026lt; (1 + LOG2NENV)) | (e - envs); } 函数使用 static 声明要分配的 asid 段的内容，使得返回值 envid 的 asid 段递增，且保证了返回值不为 0。0 作为一个保留值，在 envid 的判断中有如下的作用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int envid2env(u_int envid, struct Env **penv, int checkperm) { struct Env *e; /* Step 1: Assign value to \u0026#39;e\u0026#39; using \u0026#39;envid\u0026#39;. */ /* Hint: * If envid is zero, set \u0026#39;penv\u0026#39; to \u0026#39;curenv\u0026#39; and return 0. * You may want to use \u0026#39;ENVX\u0026#39;. */ /* Exercise 4.3: Your code here. (1/2) */ if (envid) { e = \u0026amp;envs[ENVX(envid)]; } else { *penv = curenv; return 0; } //... } 当 envid 的值是 0 时，函数会使参数 penv 指向当前进程控制块，供一些系统调用函数访问当前进程的进程控制块。\nThinking 4.4\r关于 fork 函数的两个返回值，下面说法正确的是： A、fork 在父进程中被调用两次，产生两个返回值 B、fork 在两个进程中分别被调用一次，产生两个不同的返回值 C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值 D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值\n选 C。\nThinking 4.5\r我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。\n从 ULIM 开始往下看， ULIM 到 UVPT 是进程自己的页表， UVPT 到 UTOP 是所有进程共享的只读空间，这些部分存储内核相关的页表信息，在 env_alloc() 函数中被拷贝到进程页表中、不需要进行映射（Thinking 3.1）；UTOP 也就是 UXSTACKTOP ，开始往下到 USTACKTOP 则是异常处理栈和无效内存部分，不需要父子进程进行共享，所以也不需要映射。最终需要映射的页面只存在于 USTACKTOP 之下。\nThinking 4.6\r在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题：\nvpt 和 vpd 的作用是什么？怎样使用它们？ 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？ 它们是如何体现自映射设计的？ 进程能够通过这种方式来修改自己的页表项吗？ 1.\rvpt 和 vpd 分别是指向用户页表和用户页目录的指针，用来访问用户页表和页目录。\n1 2 3 #define vpt ((const volatile Pte *)UVPT) #define vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) \u0026lt;\u0026lt; PGSHIFT))) 2.\r对于一个虚拟地址 va，要获取对应的页表项，应当使用 (*vpt) + (va \u0026gt;\u0026gt; 12) == vpd[va \u0026gt;\u0026gt; 12] == vpt[VPN(va)]\n对于一个虚拟地址 va，要获取对应的页目录项，应当使用 (*vpd) + (va \u0026gt;\u0026gt; 22) == vpd[va \u0026gt;\u0026gt; 22]\n所以可以通过 vpt 和 vpd 直接访问用户进程的页表和页目录项。\n3.\r由 vpd 的定义可以看出页目录基地址在 UVPT 和 UVPT + PDMAP 之间，即页目录映射到了某一个页表的位置，在页目录中一定有一个页表项映射到了页目录本身，即实现了自映射。\n4.\r不能，页表由内核态程序进行维护，用户态下进程只能对页表项进行访问而不能修改。\nThinking 4.7\r在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：\n这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？ 内核为什么需要将异常的现场 Trapframe 复制到用户空间？ 出现异常重入：用户程序尝试写 COW 页的时候会发生异常重入。 处理 COW 页触发的页写入异常时，do_tlb_mod() 函数将 epc 改为了用户态的异常处理函数，退出内核中断后系统跳转到 epc 所指的用户态的异常处理函数，在用户态处理完毕后仍在用户态恢复现场，所以需要内核态保存的现场来指导进行恢复。 Thinking 4.8\r在用户态处理页写入异常，相比于在内核态处理有什么优势？\n按照微内核的设计理念，MOS 操作系统将处理页写入异常的功能放在了用户态。这样的实现使得：\n内核更加精简，而且要修改页写入异常的处理方法更加灵活，可以模块化地更换处理页写入异常地程序。 提升了安全性，即使用户态的异常处理代码出现问题，也不会影响到内核的稳定性。 具体到这个处理代码，它其中含有大量页面拷贝的工作，在用户态进行实现可以解放内核的资源；同时用户态下进行新页面的分配映射更加灵活方便。 Thinking 4.9\r请思考并回答以下几个问题：\n为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？ 如果放置在写时复制保护机制完成之后会有怎样的效果？ syscall_exofork() 执行完成后子进程需要修改 env 指针，涉及对 COW 页面的修改、触发 COW 写入异常，而此异常处理机制依赖 syscall_set_tlb_mod_entry 的执行，所以此顺序是固定的。 父进程调用 COW 机制可能会触发缺页异常，而此时尚未设置异常处理机制，无法按照预期处理。 二、难点分析\r如何添加一个系统调用\r用户进程调用函数 void user_lib_func(u_int whom, u_int val, const void *srcva, u_int perm) 系统调用 void syscall_func(u_int envid, u_int value, const void *srcva, u_int perm) 步骤\ruser/include/lib.h: 函数声明 * 2 user/lib/syscall_lib.c: 实现 void syscall_func(u_int envid, u_int value, const void *srcva, u_int perm)，也就是使用 msyscall user/lib/目标文件.c: 实现 void user_lib_func(u_int whom, u_int val, const void *srcva, u_int perm)，如 debugf.c 中， debug_flush 调用了 syscall_print_cons include/syscall.h: 更新枚举内容（例如 SYS_func ），注意在 MAX_SYSNO 之前。 kern/syscall_all.c: 1. 实现 sys_func ；2. 更新 syscall_table int sys_func(u_int envid, u_int value, u_int srcva, u_int perm)\n如何获取env\r同 envid2env： 1 2 3 4 5 6 struct Env *e; if (envid) { e = \u0026amp;envs[ENVX(envid)]; } 使用 extern 关键字声明 envs 数组，利用下标获取： 1 2 // kern/syscall_all.c extern struct Env envs[NENV]; fork\r让进程创建进程的方式，其特点在于，在新的进程中 fork() 的返回值为0，在父进程中返回值则为子进程的 env_id，这一特点也使得父子进程可以执行不同的后续逻辑并进行通讯操作。课下实验的后半部分内容也围绕着这个函数展开。\n三、实验体会\r这次lab的内容比较多，实现也较为复杂，光是课下部分就耗费了不少精力。在第一次课上限时测试前，我重点思考并理解了系统调用有关的部分，为我的满分通过打下了良好的基础。然而第二次课上测试虽然感觉准备的也算充分，却因故爆零，让我倍感遗憾。虽然我已经写对了绝大部分的代码，但对 sys_set_env_status 中调用 envid2env 部分的处理逻辑早已忘却，导致这个地方如何传参（envid 应该传入 0）在课上始终没有发现；并且似乎还受到了跳板机特定的影响，总之爆0了。希望后面两个lab能更加细心，常常回顾，争取实现得更好。\n","date":"2024-05-22T00:00:00Z","permalink":"http://localhost:1313/p/os-lab4-doc/","title":"OS | Lab 4 文档"},{"content":"Lab 3\r一、思考题\rThinking 3.1\r请结合 MOS 中的页目录自映射应用解释代码中 e-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V 的含义。\nUVPT: 用户页表起始处的虚拟地址 PDX(UVPT): UVPT 对应的页目录号 e-\u0026gt;env_pgdir: 进程 e 的页目录的内核虚拟地址 e-\u0026gt;env_pgdir[PDX(UVPT)]: 进程 e 的第 PDX(UVPT) 个页目录项 PADDR(e-\u0026gt;env_pgdir): 进程 e 的页目录的物理地址\n由上可知，这段代码的意义是将 UVPT 虚拟地址映射到页目录本身的物理地址，并设置只读权限，由此用户程序可以通过 UVPT 只读地访问自己的二级页表。\nThinking 3.2\relf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？\n在 load_icode 函数中调用了 elf_load_seg，传入 load_icode_mapper 作为回调函数 map_page，传入进程控制块的指针 e 作为 data。\n在 load_icode_mapper 内部有如下语句：\n1 2 3 4 5 6 static int load_icode_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len) { struct Env *env = (struct Env *)data; // ... return page_insert(env-\u0026gt;env_pgdir, env-\u0026gt;env_asid, p, va, perm); 可见 data 参数传入后还原为进程控制块的指针，为 page_insert 函数进一步提供当前进程空间的页目录基地址 env_pgdir 和地址空间标识符 env_asid，如果没有 data 这个参数，在将虚拟地址映射到页上的时候就无法知道页目录基地址，也无法区分不同进程的相同虚拟地址，故这个参数不能舍去。\nThinking 3.3\r结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。\n首先，该函数会尝试处理虚拟地址未对齐的情况，即尝试将开头没有对齐的部分先映射到内存中：\n1 2 3 4 5 6 7 8 9 10 11 // ... int r; size_t i; u_long offset = va - ROUNDDOWN(va, PAGE_SIZE); if (offset != 0) { if ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, PAGE_SIZE - offset))) != 0) { return r; } } // ... 接着处理剩下部分的数据，函数利用循环逐页将数据加载到内存中：\n1 2 3 4 5 6 for (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : 0; i \u0026lt; bin_size; i += PAGE_SIZE) { if ((r = map_page(data, va + i, 0, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) != 0) { return r; } } 接着处理果该段在文件中的内容的大小达不到为填入这段内容新分配的页面大小的情况，这里该函数将不断在内存中创建新的页，但向其传入的数据为 NULL ，即不向新页加载任何内容：\n1 2 3 4 5 6 while (i \u0026lt; sgsize) { if ((r = map_page(data, va + i, 0, perm, NULL, MIN(sgsize - i, PAGE_SIZE))) != 0) { return r; } i += PAGE_SIZE; } 以 load_icode_mapper 为例，即只执行 page_insert 操作而并不进行 memcpy 操作。由指导书可知，这样的情况可能是由 .bss 区域等情况导致的。\nThinking 3.4\r思考上面这一段话，并根据自己在 Lab2 中的理解，回答这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址。\n虚拟地址，EPC 存储的是异常发生时系统正在执行的指令的地址，指令来源于内存中可执行程序的代码段 .text，所见为虚拟地址；而且该属性赋值为 ehdr-\u0026gt;e_entry，也在定义中注释了 /* Entry point virtual address */，即为虚拟地址。\nThinking 3.5\r试找出 0、1、2、3 号异常处理函数的具体实现位置。\n0 号异常处理函数在 kern/genex.S 中直接实现：\n1 2 3 4 5 6 7 8 9 10 11 NESTED(handle_int, TF_SIZE, zero) mfc0 t0, CP0_CAUSE mfc0 t2, CP0_STATUS and t0, t2 andi t1, t0, STATUS_IM7 bnez t1, timer_irq timer_irq: li a0, 0 j schedule END(handle_int) 1、2、3 号异常的处理函数也在同文件中实现，不过利用了宏，所以无法直接使用 grep -r 搜索得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .macro BUILD_HANDLER exception handler NESTED(handle_\\exception, TF_SIZE + 8, zero) move a0, sp addiu sp, sp, -8 jal \\handler addiu sp, sp, 8 j ret_from_exception END(handle_\\exception) .endm // ... BUILD_HANDLER tlb do_tlb_refill // 1 BUILD_HANDLER mod do_tlb_mod\t// 2、3 Thinking 3.6\r阅读 entry.S、genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。\n1 2 3 4 5 6 7 // entry.S exc_gen_entry: SAVE_ALL // ... mfc0 t0, CP0_STATUS and t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) mtc0 t0, CP0_STATUS 这段代码用于在异常发生时分发异常，通过清除 Status 寄存器中的 IE 位来禁止全局中断，这个时候时钟中断被关闭；随后根据 traps.c 中的设置跳转到异常处理程序：\n如果是 handle_int，则会通过比较得到是否是时钟中断，如果是则跳转到 schedule 函数，在 env_run 函数中调用 env_pop_tf，重置时钟后使用宏 RESTORE_ALL 中恢复了 Status 寄存器，开启了中断。 1 2 3 4 5 6 7 8 9 10 // env_asm.S .text LEAF(env_pop_tf) .set reorder .set at mtc0 a1, CP0_ENTRYHI move sp, a0 RESET_KCLOCK j ret_from_exception END(env_pop_tf) 如果是其他已经实现的处理函数，则会在最后跳转到 ret_from_exception，里面同样使用了宏 RESTORE_ALL 来恢复 Status 寄存器、开启中断。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // genex.S .macro BUILD_HANDLER exception handler NESTED(handle_\\exception, TF_SIZE + 8, zero) move a0, sp addiu sp, sp, -8 jal \\handler addiu sp, sp, 8 j ret_from_exception END(handle_\\exception) .endm .text FEXPORT(ret_from_exception) RESTORE_ALL eret 宏 SAVE_ALL 和 RESTORE_ALL 是对应的，定义在 include/stackframe.h 中了，分别在分发异常和处理结束后调用。\nThinking 3.7\r阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。\n时钟中断产生后，系统跳转到 .text.exc_gen_entry 代码段执行，分发异常到 handle_int 函数进行处理，判断为时钟中断后跳转到 schedule 函数。 在 schedule 函数内，系统获得当前运行的进程控制块 curenv，使其可用时间片数量减一，然后根据进程切换的四种条件（未开始调度、当前进程时间片耗尽、当前进程不处于就绪态、参数指定发生切换）进行进程切换。 进程切换：从调度队列头取出当前进程、若该进程就绪则将其插入到调度队列尾部、从队列头取出新进程、重置剩余时间片数量为新进程优先级。 运行新进程 env_run(e) 二、难点分析\r指导书\r创建一个进程并成功运行 实现时钟中断，通过时钟中断内核可以再次获得执行权 实现进程调度，创建两个进程，并且通过时钟中断切换进程执行 在 Lab3 中将运行一个用户模式的进程。本实验需要使用数据结构进程控制块 Env 来跟踪用户进程，并建立一个简单的用户进程，加载一个程序镜像到指定的内存空间，然后让它运行起来。同时，实验实现的 MIPS 内核具有处理异常的能力。\n进程控制块\r有两个类似 Lab2 中 pp_link 的字段，分别用于构造空闲进程链表、调度队列\n创建进程\r从空闲进程链表中申请一个 struct Env 手动初始化进程控制块 初始化页目录 从空闲进程链表中移除 指导书中说第二步是本次实验的关键，也就是使用 env_setup_vm 函数初始化新进程的地址空间，实际因为重要的地方都不用我们补全，其实感觉不大难；主要是理解如何初始化，以及理解这里的页目录自映射，为后续实验做准备。\n进程运行与切换\r这里对进程上下文的保存和恢复感觉很重要，也是本届实验 exam 的一个考察点；而且这个部分与下面要说的时钟中断与进程调度联系紧密，必须要搞明白。\n中断、异常、分发\r梦回计组，但从操作系统的角度来理解中断和异常。这里的难点在于搞清楚异常/中断发生时操作系统的处理流程，包括理解异常向量组、异常处理函数；这部分也是进程调度的依赖项。\n进程调度\r跟着思考题和代码填空的节奏先过一边，然后参考指导书的说明完整地走一遍进程调度相关的代码文件，才好揭开进程调度的神秘面纱。\n三、实验体会\r这次实验做的还可以，exam 有惊无险地通过，extra 差点做出来。为了面对期中考试，狠狠地恶补了一波理论支持，为这次实验的进行提供了莫大的帮助；另一方面，不能等到限时测验结束才做思考题这一点也对我帮助很大，在完成思考题的同时我也加深了对实验内容和整体逻辑的理解。exam 做的有点手忙脚乱，不过通过不懈地尝试和利用之前提供的本地测试方法，也是成功满分拿下（虽然感觉这次 exam 难度控制地不好，可以看出学生和助教都很绷）；extra 已知对指针相关代码的写法还是不够熟练，几番尝试后也没有消除 Error；未知其它部分的处理是否还有问题，继续努力学习吧！\n","date":"2024-04-24T00:00:00Z","permalink":"http://localhost:1313/p/os-lab3-doc/","title":"OS | Lab 3 文档"},{"content":"Lab 2\r一、思考题\rThinking 2.1\r请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？\n都被视为虚拟地址。\nThinking 2.2\r从可重用性的角度，阐述用宏来实现链表的好处。 查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。 用宏来实现链表的好处： 这里用宏来实现链表，相当于借助 void * 的强制转换在C语言中实现了泛型，比如在想要同时使用两种不同数据类型的链表的时候，如果不用宏来实现链表，就需要写两种结构体、两版操作节点的代码，提高了出错率；而使用宏就没有这种烦恼，可以避免重复劳动，而且降低了出错的概率。\n而且一些复杂的宏（如 LIST_INSERT_BEFORE）可以使用简单宏（如 LIST_FIRST、LIST_NEXT），也是可重用性的体现，增强了代码的可读性。\n三者在插入与删除操作上的性能差异: 对于单向链表而言，如果要插入到某一项的前面，则需要从头开始遍历链表；如果要插入到某一项的后面，则可以直接进行插入而无需查询；删除时也需要遍历整个链表。 对于循环链表而言，其也是单向的，上述单向链表的三个性能表现它也拥有；但它可以在尾部直接插入。 对于双向链表而言，其删除和插入都是 O(1) 的。但相比于循环链表，它无法直接将某一项插入链表尾部。 TODO\rThinking 2.3\r请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // pmap.h LIST_HEAD(Page_list, Page); typedef LIST_ENTRY(Page) Page_LIST_entry_t; struct Page { Page_LIST_entry_t pp_link; /* free list link */ u_short pp_ref; }; // queue.h #define LIST_HEAD(name, type) \\ struct name { \\ struct type *lh_first; /* first element */ \\ } #define LIST_ENTRY(type) \\ struct { \\ struct type *le_next; /* next element */ \\ struct type **le_prev; /* address of previous next element */ \\ } // 展开 struct Page_list { struct { struct { struct Page *le_next; /* next element */ struct Page **le_prev; /* address of previous next element */ } pp_link; // ^ (1) u_short pp_ref; }* lh_first; /* first element */ } // ^ (2) 故选C。\nThinking 2.4\r请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID 的必要性。 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。 ASID 的必要性： ASID 为每个进程提供了一个唯一的标识符，使得操作系统能够区分进程的虚拟地址空间，即使多个进程可能需要共享相同的物理内存页，通过检查 ASID ，操作系统可以识别出正在访问的 TLB 条目的进程是否为目标进程，确保一个进程的修改不会影响其他进程的内存页。\n结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量： 在 4Kc 处理器核心中，ASID 是 8 位宽的，故其可容纳不同的地址空间最大数目为 2 ^ 8 = 256 个。\nThinking 2.5\rtlb_invalidate 和 tlb_out 的调用关系？ 请用一句话概括 tlb_invalidate 的作用。 逐行解释 tlb_out 中的汇编代码。 调用关系： tlb_invalidate 调用 tlb_out。\ntlb_invalidate 的作用： 使虚拟地址对应的 TLB 表项失效，下次访问这个地址就会触发 TLB 重填，完成对 TLB 的更新。\n逐行解释 tlb_out 中的汇编代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 LEAF(tlb_out) // 创建叶子函数（不调用其他函数的函数） tlb_out .set noreorder // 在接下来的代码中不要重新排序指令 mfc0 t0, CP0_ENTRYHI // TLB 目录高位部分：CP0_ENTRYHI -\u0026gt; t0 mtc0 a0, CP0_ENTRYHI // 更新的数据： a0 -\u0026gt; CP0_ENTRYHI nop nop // 为解决数据冒险插入的 nop 指令 tlbp // 根据 EntryHi 中的 Key 查找 TLB 中 // 与之对应的表项并将其索引存入 CP0_INDEX 寄存器 nop // 为解决数据冒险插入的 nop 指令 mfc0 t1, CP0_INDEX // TLB 目录索引部分：CP0_INDEX -\u0026gt; t1 .set reorder // 允许编译器重新排序指令 bltz t1, NO_SUCH_ENTRY // 如果 t1 寄存器的值为负（TLE未命中） // 则跳转到 NO_SUCH_ENTRY 进行处理 .set noreorder // 在接下来的代码中不要重新排序指令 mtc0 zero, CP0_ENTRYHI // 清空 CP0_ENTRYHI 寄存器 mtc0 zero, CP0_ENTRYLO0 // 清空 CP0_ENTRYLO0 寄存器 mtc0 zero, CP0_ENTRYLO1 // 清空 CP0_ENTRYLO1 寄存器 nop // 应该也是为了处理数据冒险而插入的 nop 指令 tlbwi // 以 Index 寄存器中的值为索引，将此时 EntryHi // 与 EntryLo0、EntryLo1 的值写到索引指定的 TLB 表项中 .set reorder // 允许编译器重新排序指令 NO_SUCH_ENTRY: // TLE未命中的处理部分 mtc0 t0, CP0_ENTRYHI // TLB 目录高位部分：t0 -\u0026gt; CP0_ENTRYHI，即进行恢复 j ra // 返回到调用处 END(tlb_out) // 标记 tlb_out 函数结束 Thinking 2.6\r简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。\nX86 体系结构中的内存管理机制是基于分段和分页的（段页式），而且有三个地址空间的概念：物理地址、线性地址和逻辑地址。具体而言，X86 体系结构通过分段将逻辑地址转换为线性地址，通过分页将线性地址转换为物理地址。\n就区别而言，在对 TLB 不命中时的处理上， MIPS 触发 TLB 缺失和重填，然后CPU再用刚刚转换失败的虚拟地址重新访问；而 X86 在 TLB 不命中时，使用硬件 MMU 索引获得页框号，直接输出物理地址，同时 MMU 会填充 TLB 以加快下次转换的速度。\nThinking A.1\r在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4 KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：三级页表页目录的基地址和映射到页目录自身的页目录项（自映射）。\n三级页表页目录的基地址： PTBase + ((PTBase \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) + ((((PTBase \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3)\n映射到页目录自身的页目录项： PTBase + ((PTBase \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) + ((((PTBase \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) + ((((((PTBase \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3)\n二、难点分析\r指导书\r了解 MIPS 4Kc 的访存流程与内存映射布局 掌握与实现物理内存的管理方法（链表法） 掌握与实现虚拟内存的管理方法（两级页表） 掌握 TLB 清除与重填的流程 核心任务是管理两级页表与填写 TLB。\n宏的理解\rPADDR(kva) ：kseg0 处虚地址 -\u0026gt; 物理地址，注意只能是 kseg0 中的虚拟地址，这个宏只完成了最高位清零的操作。 KADDR(pa) ：物理地址 -\u0026gt; kseg0 处虚地址，同上。这两个宏还有一些越界检查。 链表宏：虽然对链表的知识还没怎么忘，但是 field 字段并不好理解，其实应该相当于指针域？ 虚拟地址\rMIPS 4Kc 发出的地址均为虚拟地址，因此如果程序想访问某个物理地址，需要通过映射到该物理地址的虚拟地址来访问。对页表进行操作时硬件处于内核态，因此使用宏 KADDR 获得其位于 kseg0 中的虚拟地址即可完成转换。\n对于位于 kuseg 的虚拟地址，MOS 中采用两级页表结构对其进行地址转换。\n二级页表检索函数\rint pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)，该函数将一级页表基地址 pgdir 对应的两级页表结构中 va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上。该函数的作用是：给定一个虚拟地址，在给定的页目录中查找这个虚拟地址对应的页表项，将其地址写入 *ppte。\n1 2 3 4 5 6 7 8 9 10 u_long va = (PDX(va) \u0026lt;\u0026lt; 22) | (PTX(va) \u0026lt;\u0026lt; 12) | offset; // 虚拟地址 va Pde *pgdir; // 一级页表基地址 pgdir Pde *pgdir_entryp = pgdir + PDX(va); // 对应页目录项的对应虚拟地址 (*pgdir_entryp); // 对应页目录项的内容 PTE_ADDR(*pgdir_entryp) // 对应页表的物理基地址 KADDR(PTE_ADDR(*pgdir_entryp)) // 对应页目录项内容中的物理地址 = 对应页表的虚拟基地址 Pte *pte = (Pte*)KADDR(PTE_ADDR(*pgdir_entryp)) + PTX(va); // 页表项对应的虚拟地址 (*pte) // 页表项对应的物理地址 pa2page(*pte) // 页表项对应的页控制块 这里就出现了三个虚拟地址，要分清楚不要混淆，主要还是要理解虚拟地址的组成、二级页表的结构、页面之间的映射关系。\n页表：\n多级页表：各级页表中记录的全是物理页号，指向下级页表或真正的被访问页\n三、实验体会\r这次实验做的不好，线上线下做的都很坎坷。究其原因，主要还是理论没有理解透彻，导致对这次的实验其实没有一个整体上的把握，比如还没有理解物理内存管理的实现就匆忙地赶到虚拟内存管理部分，最后甚至在线上实验的时候没有理解几个虚拟地址的概念，用着错误的理解尝试 debug 了半天。下次实验务必要透彻理解代码实现对应的理论，不能只靠猜测和碰运气就匆忙完成代码的编写。尽量要在线下实验进行的时候就同步完成思考题，不要等到结束限时上机再追悔莫及。\n","date":"2024-04-10T00:00:00Z","permalink":"http://localhost:1313/p/os-lab2-doc/","title":"OS | Lab 2 文档"},{"content":"Lab 1\r一、思考题\rThinking 1.1\r请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。\n重复编译和解析过程 使用原生x86工具链：基本同指导书，除了发现在实验环境中调用函数的指令为 call 而非 callq，似乎是由于环境的位数差异引起的。\n使用mips交叉编译工具链：分别使用mips-linux-gnu-gcc -c hello.c （左）和 mips-linux-gnu-gcc hello.c （右）并进行反汇编 mips-linux-gnu-objdump -DS ...，结果对比如下图： 主要有两个差别，一是main 的地址发生了改变，链接后的程序有一个具体的起始地址，而不链接的情况下地址是相对的；二是一些寄存器的值发生了变化，特别是存储函数地址的 t9 寄存器，链接与否决定其能否存储一个正确的函数地址而非默认值。\n解释 objdump -DS 中的参数含义 1 2 3 4 5 objdump --help -D, --disassemble-all Display assembler contents of all sections // 显示所有节的汇编程序内容 --disassemble=\u0026lt;sym\u0026gt; Display assembler contents from \u0026lt;sym\u0026gt; -S, --source Intermix source code with disassembly // 同时输出源码 Thinking 1.2\r尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf -h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同） 进行解析： 运行 ./readelf readelf 无输出；运行 readelf -h readelf: 这是为什么呢？从 Makefile 中可以看出有几处不同：\n1 2 3 4 5 readelf: main.o readelf.o $(CC) $^ -o $@ hello: hello.c $(CC) $^ -o $@ -m32 -static -g 具体来说，hello的编译指令中包含了-m32、-static和-g三个参数：\n-m32: 不管环境是32位还是64位，都编译生成32位的可执行文件。 -static: 链接时使用静态链接，将所有需要的库包含在最终的可执行文件中。 -g: 编译时包含调试信息。 而且我们编写的 readelf 程序可以解析 hello 文件，对比 readelf -h readelf 可以发现 readelf 本身是64位的。重新回到 readelf.c 中可以发现各种数据结构只支持解析 32 的可执行文件的，问题也就迎刃而解了。\nThinking 1.3\r在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）\nMIPS 体系结构上电时，CPU从预定义的启动入口地址开始执行 bootloader，其会将内核镜像从存储器读到 RAM 中，并为内核设置启动参数，最后将 CPU 指令寄存器的内容设置为内核入口函数的地址，即将控制权转交给操作系统内核。因此启动入口地址不是放在上电启动地址的，需要经过 bootloader 的一系列引导以跳转到内存中的入口。而 QEMU 已经提供了 bootloader 的引导（启动）功能，而且支持加载 ELF 格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口，启动就完成了。\n二、难点分析\r指导书\r理解 Makefile 语法 理解 ELF 文件结构，包括三个重要的节 .text、.data、.bss printk 函数过程 线下-Exercise1.1\r理解相关文件内容，在 readelf.c 中进行两处填空，需要理解 Elf32_Ehdr、Elf32_Shdr 两个结构体中成员的意义。\n在 ELF 头中，提供了节头表的入口偏移，假设 binary 为 ELF 的文件头地址，shoff为入口偏移，那么 binary + shoff 即为节头表第一项的地址。 遍历每一个节头的方法是：先读取节头的大小，随后以指向第一个节头的指针（即节头表第一项的地址）为基地址，不断累加得到每个节头的地址。 线下-Exercise1.2\r将内核调整到正确的位置上：根据内存布局图设置内核位置即可。\n线下-Exercise1.3\r设置栈指针，注意栈的增长方向：根据内存布局图设置栈指针即可； 跳转到 mips_init: j mips_init\n线下-Exercise1.4\r补全 vprintfmt()：根据功能和代码注释填空，还好可以参考上下文和注释，无法想象没有注释怎么写出来，主要是很难一开始就对代码有一个清晰的理解。考验阅读代码的能力。\n线上-lab1-exam\r实现一个自定义的格式化字符串\u0026rsquo;%P\u0026rsquo;：从当前参数位往后读取两个参数，输出三个参数，第三个参数由前两个参数计算而来。注意格式串依然为 %[flags][width][length]\u0026lt;specifier\u0026gt;，仍然需要考虑 P 前可能出现的格式要求，不过在写 print_num 的时候应该会考虑到一部分，注意 long_flag 和 neg_flag 即可。\n线上-lab1-extra\r实现 scanf，实际上要求对 printk 的原理充分理解，包括对变长参数表相关的宏和变量类型的理解，对 in/out 辅助函数的理解，对指针的使用等。\n三、实验体会\r纸上得来终觉浅，然而纸上也没那么好得来。感觉大概熟悉节奏了，需要\n粗看把握整体概念和层次 尝试写代码 再看指导书，查阅相关资料 重复步骤2、3，直到真正弄懂一次lab ","date":"2024-03-27T00:00:00Z","permalink":"http://localhost:1313/p/os-lab1-doc/","title":"OS | Lab 1 文档"},{"content":"Lab 0\r一、思考题\rThinking 0.1\rgit status : 查看Git仓库当前状态，包括未暂存的更改、未跟踪的文件等 README.txt 两次所处位置不同：因为两次运行之间使用了 add 命令，将 README.txt 文件的状态由未跟踪变为跟踪后的暂存状态，显示为“新文件”。 Modified.txt 与 Stage.txt 内容不同，在暂存区，README.txt由显示“新文件”变为了显示“修改”，这是因为在提交 README.txt 文件后修改了其中内容，被Git跟踪到了其中内容的变化；Modified.txt 还有提示“修改尚未加入提交”。 Thinking 0.2\rgit add 命令本身具有多义性\nadd the file: git add stage the file: git add commit: git commit Thinking 0.3\r普通恢复：使用 git checkout -- printf.c 执行 git rm 之后的恢复：先使用 git reset HEAD printf.c ，再执行 git checkout -- printf.c 不删除文件的前提下将文件移出暂存区：git rm --cached hello.txt Thinking 0.4\r3 的哈希值：e1f01368955db9ce42acbc45c46ac690b08ebc1b 1 的哈希值：d03caef65f470e56d6639d0048d896e41cd87bc7\n执行 git reset --hard HEAD^：回退了一个版本，提交说明为3的提交在日志中消失了 执行 git reset --hard \u0026lt;1's hash\u0026gt;：再次回退了一个版本，提交说明为2的提交在日志中消失了 执行 git reset --hard \u0026lt;3's hash\u0026gt;：回到3版本，日志中可以看到1、2、3提交记录 小结：可以使用git reset来切换版本，可以使用HEAD[^]*、HEAD-num形式，也可以直接使用版本对应的hash值。\nThinking 0.5\rThinking 0.6\rcommand:\nresult:\n在 test 中我们给 a b c 分别 赋值为 1 2 3，然后写入file3、file2、file1中，然后以file1、file2、file3的顺序将文件的内容追加写入到file4中，再将file4写入到result中，故result的内容为\n1 2 3 3 2 1 echo echo Shell Start 与 echo \u0026rsquo;echo Shell Start\u0026rsquo;：效果没有区别 echo echo $c\u0026gt;file1 与 echo \u0026rsquo;echo $c\u0026gt;file1\u0026rsquo;：效果有区别，前者将 echo \\$c 重定向到file1，而后者将\u0026rsquo;echo $c\u0026gt;file1\u0026rsquo;这一字符串输出到终端。 二、难点分析\r三、实验体会\r线下实验：整体难度梯度比较合理，体验较为丝滑，感谢课程组提供的串讲，我认为任务导向的学习是非常好的。 线上实验：评测系统有点幽默，一方面会因为评测压力而导致问题，并且没有及时告知什么情况下是评测系统的问题什么时候是提交文件问题；一方面我看不懂报错提示，可能还是对linux相关掌握不精。对awk的介绍过少，一方面说awk是“学有余力的同学可以自行深入学习”，一方面明明使用awk语法可以优雅地完成extra的要求，私以为线上实验前应该引导学生学习awk。 ","date":"2024-03-13T00:00:00Z","permalink":"http://localhost:1313/p/os-lab0-doc/","title":"OS | Lab 0 文档"},{"content":"计组实验 P7 设计文档\n全力转发优化：Tuse进行区分 cal_rr\rIns add sub and or slt sltu func 10 0000 10 0010 10 0100 10 0101 10 1010 10 1011 op 00 0000 00 0000 00 0000 00 0000 00 0000 00 0000 TargetReg D D D D D D ALUSrc T T T T T T Mem2Reg ALU ALU ALU ALU ALU ALU RegWrite 1 1 1 1 1 1 MemWrite 0 0 0 0 0 0 NPCop PCPlus4 PCPlus4 PCPlus4 PCPlus4 PCPlus4 PCPlus4 ExtOp 0 0 0 0 0 0 ALUop add sub and or slt sltu Tuse_rs 1 1 1 1 1 1 Tuse_rt 1 1 1 1 1 1 TnewE 1 1 1 1 1 1 cal_ri + lui\rIns addi andi ori lui op 00 1000 00 1100 00 1101 00 1111 TargetReg T T T T ALUSrc I I I I Mem2Reg ALU ALU ALU ALU RegWrite 1 1 1 1 MemWrite 0 0 0 0 NPCop PCPlus4 PCPlus4 PCPlus4 PCPlus4 ExtOp 1 0 0 x ALUop add and or lui Tuse_rs 1 1 1 x Tuse_rt x x x x TnewE 1 1 1 1 load + store\rIns lb lh lw sb sh sw op 10 0000 10 0001 10 0011 10 1000 10 1001 10 1011 TargetReg D D D x x x ALUSrc T T T T T T Mem2Reg MEM MEM MEM x x x RegWrite 1 1 1 0 0 0 MemWrite 0 0 0 1 1 1 NPCop PCPlus4 PCPlus4 PCPlus4 PCPlus4 PCPlus4 PCPlus4 ExtOp 1 1 1 1 1 1 ALUop add add add add add add Tuse_rs 1 1 1 1 1 1 Tuse_rt x x x 2 2 2 TnewE 2 2 2 x x x mult div mf mt\rIns mult div mf mt TargetReg x x D x ALUSrc x x x x Mem2Reg x x MD x RegWrite 0 0 1 0 MemWrite 0 0 0 0 NPCop PCPlus4 PCPlus4 PCPlus4 PCPlus4 ExtOp 0 0 0 0 ALUop x x x x Tuse_rs 1 1 x 1 Tuse_rt 1 1 x x TnewE x x 1 x start 1 1 0 0 注意设置MDOp\njump\rIns beq bne jal jr j TargetReg x x 31 x x ALUSrc x x x x x Mem2Reg x x PCPlus8 x x RegWrite 0 0 1 0 0 MemWrite 0 0 0 0 0 NPCop beq bne Jimm26 JReg Jimm26 ExtOp x x x x x ALUop x x x x x Tuse_rs 0 0 x 0 x Tuse_rt 0 0 x x x TnewE x x 0 x x 优化思路：lui提前处理，TnewE=0；对sw区分Tuse\n处理器应支持如下指令集：\n1 2 3 4 5 6 nop, add, sub, and, or, slt, sltu, lui addi, andi, ori lb, lh, lw, sb, sh, sw mult, multu, div, divu, mfhi, mflo, mthi, mtlo beq, bne, jal, jr mfc0, mtc0, eret, syscall 一、设计草稿\r1. F级\r取指令单元IFU\r含有次地址计算单元NPC和程序计数器PC；IM 容量为 16KiB（4096 × 32bit）,在mips_tb.v中实现\n端口说明\r序号 信号名称 方向 描述 1 Req I P7新增：Req信号，进入处理程序请求 2 eret_D I P7新增：指示D级指令是否为eret 3 EPCOut[31:0] I P7新增：EPC的值 4 reset I 同步复位信号，高电平有效，置pc为0x0000_3000 5 clk I 时钟信号 6 stallF I 阻塞控制信号 7 pcF[31:0] I F级指令地址 8 pcD[31:0] I D级指令地址 9 offset[15:0] I 16位立即数 10 imm26[25:0] I j、jal指令使用的26位立即数 11 NPCop[2:0] I NPC行为控制信号 12 TR_GRF_RD1[31:0] I 寄存器rs的值，可用于beq相等判断和jr指令使用 13 TR_GRF_RD2[31:0] I 寄存器rt的值，可用于beq相等判断 14 NPCoutput[31:0] O 下一条指令的地址 功能定义\r序号 功能 描述 1 复位 同步复位，置pc为0x0000_3000 2 更新 在时钟上升沿，更新pc的值为NPCoutput D级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 stallD I 阻塞控制信号 4 xxF I 需要流水的F级数据 5 xxD O D级接收的流水数据 2. D级\r控制器CTRL\r分布式译码形式的控制器，实例化为ctrl_d\n端口说明\r序号 信号名称 方向 描述 1 func[5:0] I 指令的5-0位，对R型指令进行进一步判别 2 Opcode[5:0] I 指令的31-26位 3 targetRegSel[1:0] O 写入寄存器指示信号，控制写入rt、rd、31 4 aluSrc O ALU输入选择信号，高电平时为ImmExtended，低电平时为RD2 5 mem2Reg[1:0] O 写入寄存器堆数据选择信号，控制从DM、aluResult、PC+8写入 6 regWrite O 高电平时寄存器堆写入使能，低电平时寄存器堆不可写入 7 memWrite O 高电平时DM写入使能，低电平时DM不可写入 8 NPCop[2:0] O 控制NPC行为 9 ExtOp O 高电平时EXT进行符号拓展，低电平时EXT进行0拓展 10 ALUop[3:0] O ALU运算控制信号 11 Tuse O 指示当前指令的Tuse，若有两个不同的值，输出较小值 12 TnewE O 指示当前指令在E级的Tnew 13 start O 指示乘除模块计算指令的开始信号 14 MDOp[3:0] O 指示乘除模块的行为 15 syscall O 指示当前指令是否为syscall 16 RI O 指示当前指令产生RI错误 17 isOvInstr O 指示当前指令是否关联Ov错误 18 CP0WriteEn O CP0写使能信号 功能定义\r根据func和Opcode解析指令类型，进而构建数据通路\n控制信号对应\rIns add sub ori lui lw sw beq jal jr func 10 0000 10 0010 x x x x x x 001000 op 00 0000 00 0000 00 1101 00 1111 10 0011 10 1011 00 0100 000011 000000 TargetReg 1 1 0 0 0 x x 2(31) x ALUSrc 0 0 1 1 1 1 0 x x Mem2Reg 0 0 0 0 1 x x 2(PC+8) x RegWrite 1 1 1 1 1 0 0 1 0 MemWrite 0 0 0 0 0 1 0 0 0 NPCop x x x x x x x x x ExtOp x x 0 0 1 1 1 x x ALUop add sub or shift add add sub x x Tuse 1 1 1 1 1 1 0 x 0 TnewE 1 1 1 1 2 x x 0 x D级转发接收端选择器TR_GRF_Data\r分别实例化为tr_grf_d1，tr_grf_d2\n端口说明\r序号 信号名称 方向 描述 1 grfData[31:0] I 寄存器数据 2 trDataE[31:0] I E级发来的转发数据 2 trDataM[31:0] I M级发来的转发数据 2 trDataW[31:0] I W级发来的转发数据 5 grfOutTrOp[1:0] I 选择器行为控制信号 8 trData[31:0] O 转发出去的数据 寄存器堆GRF\r端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 WE I 写使能信号，高电平有效 4 A1[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD1 5 A2[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD2 6 A3[4:0] I 5位地址输入信号，指定寄存器位置，将WD数据写入到寄存器 7 WD [31:0] I 32位写入数据内容 8 RD1 [31:0] O 输出A1指定的寄存器的32位数据 9 RD2 [31:0] O 输出A2指定的寄存器的32位数据 功能定义\r序号 功能 描述 1 同步复位 reset有效时同步复位所有寄存器 2 读出数据 将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出 3 写入数据 当WE有效且clk上升沿来临时将WD数据写入到A3指定的寄存器 扩展单元EXT\r端口说明\r序号 信号名称 方向 描述 1 IN[15:0] I 要扩展的16位立即数 2 ExtOp I 扩展方式控制信号，高电平时进行符号拓展，低电平时进行零拓展 3 OUT[31:0] O 扩展结果 功能定义\r根据ExtOp信号对立即数进行对应拓展\nE级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效，输入为STALL 2 clk I 时钟信号 3 xxD I 需要流水的D级数据 4 xxE O E级接收的流水数据 3. E级\r省略E级控制器\nE级转发接收端选择器TR_ALU_SRC\r分别实例化为tr_alu_src1，tr_alu_src2\n端口说明\r序号 信号名称 方向 描述 1 TR_GRF_RD[31:0] I 寄存器数据 2 trDataM[31:0] I M级发来的转发数据 2 trDataW[31:0] I W级发来的转发数据 5 trSel[1:0] I 选择器行为控制信号 8 aluSrc[31:0] O 转发出去的数据 寄存器写入地址选择器WR_MUX\r序号 信号名称 方向 描述 1 rt[4:0] I rt寄存器地址 2 rd[4:0] I rd寄存器地址 2 sel[1:0] I 选择器行为控制信号 8 writeRegAddr[4:0] O 寄存器写入地址 ALU输入源2选择器ALUSRC_MUX\r序号 信号名称 方向 描述 1 rtData[31:0] I rt寄存器数据 2 immExtended32[31:0] I 扩展后的立即数 2 aluSrcSel I 选择器行为控制信号 8 src2[31:0] O alu输入源数据 算数运算单元ALU\r端口说明\r序号 信号名称 方向 描述 1 src1[31:0] I ALU计算的第一个操作数 2 src2[31:0] I ALU计算的第二个操作数 3 aluop[3:0] I ALU功能选择信号，MIPS-C指令集需要9种运算 4 res [31:0] O 输出计算结果 功能定义\r支持无符号加、无符号减、或、与、异或、src2左移16位，aluop见def.v\n序号 功能 ALUop 描述 1 无符号加 00 res = src1 + src2 2 无符号减 01 res = src1 - src2 3 或 10 res = src1 | src2 4 src2左移16位 11 res = src2 \u0026laquo; 0x10 乘除运算单元MD_CAL\r端口说明\r序号 信号名称 方向 描述 1 reset I 复位信号 2 clk I 时钟信号 3 start I 乘除运算开始控制信号 4 MDOp[3:0] I 乘除行为控制信号 5 A[31:0] I 第一个操作数 6 B[31:0] I 第二个操作数 7 busy O 模块忙信号 8 HIout[31:0] O 供外界读取的HI寄存器数据 9 LOout[31:0] O 供外界读取的LO寄存器数据 10 MDRead[31:0] O 选择后输出的读出数据，受MDOp控制 11 Req O 指示是否进入处理程序，如进入则乘除运算暂停 功能定义\r自 Start 信号有效后的第 1 个 clock 上升沿开始，乘除法部件开始执行运算，同时将 Busy 置位为 1。 在运算结果保存到 HI 寄存器和 LO 寄存器后，Busy 位清除为 0。 当 Busy 信号或 Start 信号为 1 时，mult, multu, div, divu, mfhi, mflo, mthi, mtlo 等乘除法相关的指令均被阻塞在 D 流水级。 数据写入 HI 寄存器或 LO 寄存器，均只需 1 个时钟周期。 E级转发输出端选择器WRD_MUX\r序号 信号名称 方向 描述 1 aluOut[31:0] I alu运算结果 2 dmDataOut[31:0] I DM读出的数据 3 pc[31:0] I 当前指令的地址 4 MDDataOut[31:0] I 乘除模块读出数据 5 CP0Out[31:0] I CP0读出数据 6 trSel[1:0] I 选择器行为控制信号，来源为mem2Reg 7 aluSrc[31:0] O 转发出去的数据 M级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 xxE I 需要流水的E级数据 4 xxM O M级接收的流水数据 4. M级\r省略控制器和转发输出的选择器\n数据扩展模块LOAD_EXT\r端口说明\r序号 信号名称 方向 描述 1 low2Bit[1:0] I 要取地址的低两位，来自ALU计算结果 2 dataIn[31:0] I 输入的 32 位数据 3 opCode[5:0] I 该阶段指令的opCode 4 dataOut[31:0] O 扩展后的 32 位数据 5 AdEL_nonOF_M O .. 功能定义\r对于 lb、lh 来说，我们需要额外增加一个数据扩展模块。这个模块把从数据存储器读出的数据做符号扩展。\n字节使能模块BYTE_EN\r端口说明\r序号 信号名称 方向 描述 1 low2Bit[1:0] I 要取地址的低两位，来自ALU计算结果 2 RD2[31:0] I 输入的 32 位寄存器数据 3 opCode[5:0] I 该阶段指令的opCode 4 en I 向内存写使能信号 5 dataToDM[31:0] O 修改后的向内存写数据 6 byteen[3:0] O 字节使能信号 7 AdES_nonOF_M O .. 功能定义\r按字节来访问内存的使能信号和输入数据控制模块\nW级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 xxM I 需要流水的M级数据 4 xxW O W级接收的流水数据 CP0协处理器\r端口说明\r序号 信号名称 方向 描述 1 clk I 时钟信号 2 reset I 复位信号 3 en I CP0写使能信号 4 CP0Addr[4:0] I 寄存器地址 5 CP0IN[31:0] I CP0写入数据 6 VPC[31:0] I 受害PC 7 BDIn I 是否为延迟槽指令 8 ExcCodeIn[4:0] I 异常码 9 HWInt[5:0] I 输入中断信号 10 EXLClr I 复位EXL信号 11 CP0Out[31:0] O CP0读出数据 12 EPCOut[31:0] O EPC的值 13 Req O 进入处理程序请求 功能定义\r1、对异常进行配置 2、记录异常信息\n5. W级\r省略控制器和转发输出的选择器\n6. 异常产生和传递\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 wire isStoreE, isLoadE; wire isOverFlowE; wire AdES_OF_E = isStoreE \u0026amp;\u0026amp; isOverFlowE; wire AdEL_OF_E = isLoadE \u0026amp;\u0026amp; isOverFlowE; wire Ov_E = isOvInstrE \u0026amp;\u0026amp; isOverFlowE; wire [4:0] ExcCodeF = AdEL_F ? 5\u0026#39;b00100 : 5\u0026#39;b10000; reg [4:0] ExcCodeTransD; wire [4:0] ExcCodeD = (ExcCodeTransD != 5\u0026#39;b10000) ? ExcCodeTransD : Syscall_D ? 5\u0026#39;b01000 : RI_D ? 5\u0026#39;b01010 : 5\u0026#39;b10000; reg [4:0] ExcCodeTransE; wire [4:0] ExcCodeE = (ExcCodeTransE != 5\u0026#39;b10000) ? ExcCodeTransE : Ov_E ? 5\u0026#39;b01100 : 5\u0026#39;b10000; reg [4:0] ExcCodeTransM; wire [4:0] ExcCodeM = (ExcCodeTransM != 5\u0026#39;b10000) ? ExcCodeTransM : AdEL_M ? 5\u0026#39;b00100 : AdES_M ? 5\u0026#39;b00101 : 5\u0026#39;b10000; always @(posedge clk ) begin if (reset | Req) begin ExcCodeTransD \u0026lt;= 5\u0026#39;b10000; ExcCodeTransE \u0026lt;= 5\u0026#39;b10000; ExcCodeTransM \u0026lt;= 5\u0026#39;b10000; end else begin ExcCodeTransD \u0026lt;= ExcCodeF; ExcCodeTransE \u0026lt;= ExcCodeD; ExcCodeTransM \u0026lt;= ExcCodeE; end end 7. 宏定义和阻塞转发单元\r宏定义\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // for ALU `define ALU_add 4\u0026#39;b000 `define ALU_sub 4\u0026#39;b001 `define ALU_or 4\u0026#39;b010 `define ALU_and 4\u0026#39;b011 `define ALU_xor 4\u0026#39;b100 `define ALU_lui 4\u0026#39;b101 `define ALU_slt 4\u0026#39;b110 `define ALU_sltu 4\u0026#39;b111 // for GRF\u0026#39;s A3 `define REG_T 2\u0026#39;b00 `define REG_D 2\u0026#39;b01 `define REG_31 2\u0026#39;b10 // for GRF\u0026#39;s WD `define FromALURes 2\u0026#39;b00 `define FromMem 2\u0026#39;b01 `define FromPCAdd8 2\u0026#39;b10 `define FromMDRes 2\u0026#39;b11 // for NPC `define NPC_PCPlus4 3\u0026#39;b01 `define NPC_BEQ 3\u0026#39;b10 `define NPC_Jimm26 3\u0026#39;b11 `define NPC_JReg 3\u0026#39;b100 `define NPC_blztal 3\u0026#39;b101 `define NPC_BNE 3\u0026#39;b110 // for TR `define TR_FromE 2\u0026#39;b11 `define TR_FromM 2\u0026#39;b10 `define TR_FromW 2\u0026#39;b01 `define TR_FromOrigin 2\u0026#39;b00 // for MD `define MD_NOP 4\u0026#39;b000 `define MD_MULT 4\u0026#39;b001 `define MD_MULTU 4\u0026#39;b010 `define MD_DIV 4\u0026#39;b011 `define MD_DIVU 4\u0026#39;b100 `define MD_MTLO 4\u0026#39;b101 `define MD_MTHI 4\u0026#39;b110 `define MD_MFLO 4\u0026#39;b111 `define MD_MFHI 4\u0026#39;b1000 阻塞转发单元\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 assign tr_grf_rd1_sel_d = (regWriteE == 1 \u0026amp;\u0026amp; TnewE == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrE) ? `TR_FromE : (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_grf_rd2_sel_d = (regWriteE == 1 \u0026amp;\u0026amp; TnewE == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrE) ? `TR_FromE : (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_alu_src1_sel_e = (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rsAddrE != 0 \u0026amp;\u0026amp; rsAddrE == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rsAddrE != 0 \u0026amp;\u0026amp; rsAddrE == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_alu_src2_sel_e = (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rtAddrE != 0 \u0026amp;\u0026amp; rtAddrE == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rtAddrE != 0 \u0026amp;\u0026amp; rtAddrE == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign STALL = ((Tuse \u0026lt; TnewE) \u0026amp;\u0026amp; ((regWriteE == 1 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrE) || (regWriteE == 1 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrE))) || ((Tuse \u0026lt; TnewM) \u0026amp;\u0026amp; ((regWriteM == 1 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrM) || (regWriteM == 1 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrM))) || (MDOpD != `MD_NOP \u0026amp;\u0026amp; (startE || busy)) ? 1\u0026#39;b1 : 2\u0026#39;b0; hint\rfunction 1 2 3 4 function [data_type] function_name (input_declaration); [function_body] [return statement] endfunction 例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module fun_user ( input a, input b, input c, output [3:0] d, output [3:0] d2 ); function [3:0] dataout; input a; input b; input c; dataout = {a,b,c}; endfunction assign d = dataout(a,b,c); endmodule 8. 系统桥\r端口说明\r序号 信号名称 方向 描述 1 PrAddr[31:0] I 要读写的地址 2 PrWD[31:0] I 要写入的数据 3 PrWE I 写使能 4 TC1_RD[31:0] I 计时器1读出数据 5 TC2_RD[31:0] I 计时器2读出数据 6 DM_RD[31:0] I DM读出数据 7 WE_TC1 O TC1写使能 8 WE_TC2 O TC2写使能 9 WE_DM O DM写使能 10 PrRD[31:0] O CPU读取的数据 功能定义\r给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口\n二、思考题\r请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？\n鼠标、键盘的输入信号传入控制器，通过驱动程序产生中断信号，中断CPU的运行，使得CPU进入中断状态执行中断处理程序处理读入的信息。\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）\n我认为是可以自定义入口地址的，比如把入口地址的存储从常量改为寄存器，刚通电时初始化为默认值，而可以在后续进行修改。\n为何与外设通信需要 Bridge？\n遵循高内聚低耦合的原则，CPU不必知道数据具体的来源，而只需要一个统一的接口进行读写；而各种外设遵循的协议可能不同，需要通过一系列的处理方法（如驱动程序），最后受Bridge处理，统一读写的逻辑。\n请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。\nMode 0： 计时器倒数至0后停止计数，计数使能变为0，中断信号保持为1直到屏蔽中断/重新开始计数\nMode 1：\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？\n会导致宏观pc显示不正确（为0）；在清空流水线的时候，应该保留原指令的PC值信息。\n为什么 jalr 指令为什么不能写成 jalr $31, $31？\n该指令的两个行为没有指定执行顺序，rs=rd条件下产生undefined behaviour；如果指令写成这样，且该指令的延迟槽指令出现了异常/需要响应中断，那么无法通过重新执行jalr来恢复，因为$31寄存器的值已经发生了改变，再次执行jalr指令时会跳转到不正确的PC地址。\n三、测试方案\r使用课程组提供的测试数据和Mars进行对拍 自行构造数据，和同学进行对拍 ","date":"2023-12-03T00:00:00Z","permalink":"http://localhost:1313/p/co-p7-doc/","title":"CO | P7 - Verilog 流水线 CPU 设计文档"},{"content":"计组实验 P6 设计文档\n优化思路：lui提前处理，TnewE=0；对sw区分Tuse\n处理器应支持如下指令集：\n1 2 3 4 5 add, sub, and, or, slt, sltu, lui addi, andi, ori lb, lh, lw, sb, sh, sw mult, multu, div, divu, mfhi, mflo, mthi, mtlo beq, bne, jal, jr 零、教程摘录\r从状态机的角度分析，P5 阶段的 CPU 出现功能错误只有这些可能：指令执行流错误（ PC 错误）；写入 GRF 错误；写入 DM 错误。 五级流水线：Fetch，Decode，Execute，Memory，Writeback 流水数据的选择：一般而言，我们需要流水的数据只有一个衡量标准，就是我们在其后的流水阶段中需不需要这个数据，比如说 ALU 的计算结果，有的会被写回寄存器文件中，所以我们需要流水这个数据，而 rs 对应的寄存器值，在 M 级和 W 级并没有用到，所以就可以不再流水（仅一般情况）。当一个数据被选择成为了流水数据，那么其在 CPU 中就可能存在多个值。比如 E, M, W 级均会有 ALU 的计算结果（三者并不相同），在编程的时候应当使用流水阶段名前缀将其区分开。 1. 冒险\r结构冒险：不同指令同时需要使用同一资源。本实验采用哈佛体系结构，需要考虑的结构冒险为寄存器文件需要在 D 级和 W 级同时被使用（读写）时并且读和写的寄存器为同一个寄存器时。 控制冒险：分支指令（如 beq ）的判断结果会影响接下来指令的执行流。在判断结果产生之前，我们无法预测分支是否会发生。然而，此时流水线还会继续取指，让后续指令进入流水线。这时就有可能导致错误的产生，即不该被执行的指令进入到了指令的执行流中。 数据冒险：后面指令需求的数据，正好就是前面指令供给的数据，而后面指令在需要使用数据时，前面供给的数据还没有存入寄存器堆，从而导致后面的指令不能正常地读取到正确的数据。 解决方法：尽量转发（重定向数据），否则阻塞 要求大家所有转发数据都来源于流水寄存器而不能是功能部件 2. 流水线实现\r阻塞\r课程组要求阻塞是指将指令阻塞在 D 级。当一个指令到达 D 级后，我们需要将它的 $T_{use}​$ 值与后面每一级的 $T_{new}​$​ 进行比较（当然还有 A 值的校验），当 $T_{use}​$\u0026lt; $T_{new}​$时，我们需要阻塞流水线。 阻塞的实现：（1）冻结PC的值；（2）冻结D级流水线寄存器的值；（3）清零E级流水线寄存器的值（等价于插入nop指令） 注意复位信号和阻塞信号的优先级问题。仔细设计信号的优先级来保证流水线的正确性。 转发\r为了实现转发，我们需要两种多路选择器 MUX，分别对应转发的供给者和需求者。\n控制器\r解决冒险需要进行 AT 值的比较判断，并需要根据判断的结果产生特定的控制信息。这些功能要求我们丰富我们的控制器，使其可以支持这些功能。控制器需要产生的信号包括但不限于冻结信号，刷新信号，供给者选择器信号，需求者选择器信号等。\n转发优先级：选择流水线中靠前的“新鲜”的数据进行转发 rt域有效性：有些指令的 rt 域不是用来表示读寄存器编号的，但不需要对它们进行特判：即使我们转发了相应的数据，也不会影响流水线的正确性，因此无需特判。\n延迟槽\r延迟槽就是所有跳转类指令，不论是条件转移满足转移条件（即beq等）还是非条件转移（即j，jr，jal等），它的下一条指令都被写mips汇编程序者写成了一条程序中必须会完成的指令，必须进入流水线，完成所有的步骤。换言之，对于条件转移类指令，无论是否满足转移条件，它的下一条指令都需要执行；对于非条件转移类指令，它的下一条指令也必须执行，所以，在F级不需要设置NPC模块，只需要ADD4模块，而在D级设置NPC模块，它的PC+8指令才是转移后的指令。总结来讲，支持延迟槽就是编写mips汇编语言的人用他们的智慧给搭建流水线CPU的人提供便利。\n一、设计草稿\r1. F级\r取指令单元IFU\r含有次地址计算单元NPC和程序计数器PC；IM 容量为 16KiB（4096 × 32bit）,在mips_tb.v中实现\n端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效，置pc为0x0000_3000 2 clk I 时钟信号 3 stallF I 阻塞控制信号 4 pcF[31:0] I F级指令地址 5 pcD[31:0] I D级指令地址 6 offset[15:0] I 16位立即数 7 imm26[25:0] I j、jal指令使用的26位立即数 8 NPCop[2:0] I NPC行为控制信号 9 TR_GRF_RD1[31:0] I 寄存器rs的值，可用于beq相等判断和jr指令使用 10 TR_GRF_RD2[31:0] I 寄存器rt的值，可用于beq相等判断 11 NPCoutput[31:0] O 下一条指令的地址 功能定义\r序号 功能 描述 1 复位 同步复位，置pc为0x0000_3000 2 更新 在时钟上升沿，更新pc的值为NPCoutput D级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 stallD I 阻塞控制信号 4 xxF I 需要流水的F级数据 5 xxD O D级接收的流水数据 2. D级\r控制器CTRL\r分布式译码形式的控制器，实例化为ctrl_d\n端口说明\r序号 信号名称 方向 描述 1 func[5:0] I 指令的5-0位，对R型指令进行进一步判别 2 Opcode[5:0] I 指令的31-26位 3 targetRegSel[1:0] O 写入寄存器指示信号，控制写入rt、rd、31 4 aluSrc O ALU输入选择信号，高电平时为ImmExtended，低电平时为RD2 5 mem2Reg[1:0] O 写入寄存器堆数据选择信号，控制从DM、aluResult、PC+8写入 6 regWrite O 高电平时寄存器堆写入使能，低电平时寄存器堆不可写入 7 memWrite O 高电平时DM写入使能，低电平时DM不可写入 8 NPCop[2:0] O 控制NPC行为 9 ExtOp O 高电平时EXT进行符号拓展，低电平时EXT进行0拓展 10 ALUop[3:0] O ALU运算控制信号 11 Tuse O 指示当前指令的Tuse，若有两个不同的值，输出较小值 12 TnewE O 指示当前指令在E级的Tnew 13 start O 指示乘除模块计算指令的开始信号 14 MDOp[3:0] O 指示乘除模块的行为 功能定义\r根据func和Opcode解析指令类型，进而构建数据通路\n控制信号对应\rIns add sub ori lui lw sw beq jal jr func 10 0000 10 0010 x x x x x x 001000 op 00 0000 00 0000 00 1101 00 1111 10 0011 10 1011 00 0100 000011 000000 TargetReg 1 1 0 0 0 x x 2(31) x ALUSrc 0 0 1 1 1 1 0 x x Mem2Reg 0 0 0 0 1 x x 2(PC+8) x RegWrite 1 1 1 1 1 0 0 1 0 MemWrite 0 0 0 0 0 1 0 0 0 NPCop x x x x x x x x x ExtOp x x 0 0 1 1 1 x x ALUop add sub or shift add add sub x x Tuse 1 1 1 1 1 1 0 x 0 TnewE 1 1 1 1 2 x x 0 x D级转发接收端选择器TR_GRF_Data\r分别实例化为tr_grf_d1，tr_grf_d2\n端口说明\r序号 信号名称 方向 描述 1 grfData[31:0] I 寄存器数据 2 trDataE[31:0] I E级发来的转发数据 2 trDataM[31:0] I M级发来的转发数据 2 trDataW[31:0] I W级发来的转发数据 5 grfOutTrOp[1:0] I 选择器行为控制信号 8 trData[31:0] O 转发出去的数据 寄存器堆GRF\r端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 WE I 写使能信号，高电平有效 4 A1[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD1 5 A2[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD2 6 A3[4:0] I 5位地址输入信号，指定寄存器位置，将WD数据写入到寄存器 7 WD [31:0] I 32位写入数据内容 8 RD1 [31:0] O 输出A1指定的寄存器的32位数据 9 RD2 [31:0] O 输出A2指定的寄存器的32位数据 功能定义\r序号 功能 描述 1 同步复位 reset有效时同步复位所有寄存器 2 读出数据 将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出 3 写入数据 当WE有效且clk上升沿来临时将WD数据写入到A3指定的寄存器 扩展单元EXT\r端口说明\r序号 信号名称 方向 描述 1 IN[15:0] I 要扩展的16位立即数 2 ExtOp I 扩展方式控制信号，高电平时进行符号拓展，低电平时进行零拓展 3 OUT[31:0] O 扩展结果 功能定义\r根据ExtOp信号对立即数进行对应拓展\nE级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效，输入为STALL 2 clk I 时钟信号 3 xxD I 需要流水的D级数据 4 xxE O E级接收的流水数据 3. E级\r省略E级控制器\nE级转发接收端选择器TR_ALU_SRC\r分别实例化为tr_alu_src1，tr_alu_src2\n端口说明\r序号 信号名称 方向 描述 1 TR_GRF_RD[31:0] I 寄存器数据 2 trDataM[31:0] I M级发来的转发数据 2 trDataW[31:0] I W级发来的转发数据 5 trSel[1:0] I 选择器行为控制信号 8 aluSrc[31:0] O 转发出去的数据 寄存器写入地址选择器WR_MUX\r序号 信号名称 方向 描述 1 rt[4:0] I rt寄存器地址 2 rd[4:0] I rd寄存器地址 2 sel[1:0] I 选择器行为控制信号 8 writeRegAddr[4:0] O 寄存器写入地址 ALU输入源2选择器ALUSRC_MUX\r序号 信号名称 方向 描述 1 rtData[31:0] I rt寄存器数据 2 immExtended32[31:0] I 扩展后的立即数 2 aluSrcSel I 选择器行为控制信号 8 src2[31:0] O alu输入源数据 算数运算单元ALU\r端口说明\r序号 信号名称 方向 描述 1 src1[31:0] I ALU计算的第一个操作数 2 src2[31:0] I ALU计算的第二个操作数 3 aluop[3:0] I ALU功能选择信号，MIPS-C指令集需要9种运算 4 res [31:0] O 输出计算结果 功能定义\r支持无符号加、无符号减、或、与、异或、src2左移16位，aluop见def.v\n序号 功能 ALUop 描述 1 无符号加 00 res = src1 + src2 2 无符号减 01 res = src1 - src2 3 或 10 res = src1 | src2 4 src2左移16位 11 res = src2 \u0026laquo; 0x10 乘除运算单元MD_CAL\r端口说明\r序号 信号名称 方向 描述 1 reset I 复位信号 2 clk I 时钟信号 3 start I 乘除运算开始控制信号 4 MDOp[3:0] I 乘除行为控制信号 5 A[31:0] I 第一个操作数 6 B[31:0] I 第二个操作数 7 busy O 模块忙信号 8 HIout[31:0] O 供外界读取的HI寄存器数据 9 LOout[31:0] O 供外界读取的LO寄存器数据 10 MDRead[31:0] O 选择后输出的读出数据，受MDOp控制 功能定义\r自 Start 信号有效后的第 1 个 clock 上升沿开始，乘除法部件开始执行运算，同时将 Busy 置位为 1。 在运算结果保存到 HI 寄存器和 LO 寄存器后，Busy 位清除为 0。 当 Busy 信号或 Start 信号为 1 时，mult, multu, div, divu, mfhi, mflo, mthi, mtlo 等乘除法相关的指令均被阻塞在 D 流水级。 数据写入 HI 寄存器或 LO 寄存器，均只需 1 个时钟周期。 E级转发输出端选择器WRD_MUX\r序号 信号名称 方向 描述 1 aluOut[31:0] I alu运算结果 2 dmDataOut[31:0] I DM读出的数据 2 pc[31:0] I 当前指令的地址 5 trSel[1:0] I 选择器行为控制信号，来源为mem2Reg 8 aluSrc[31:0] O 转发出去的数据 M级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 xxE I 需要流水的E级数据 4 xxM O M级接收的流水数据 4. M级\r省略控制器和转发输出的选择器\n数据扩展模块LOAD_EXT\r端口说明\r序号 信号名称 方向 描述 1 low2Bit[1:0] I 要取地址的低两位，来自ALU计算结果 2 dataIn[31:0] I 输入的 32 位数据 3 opCode[5:0] I 该阶段指令的opCode 4 dataOut[31:0] O 扩展后的 32 位数据 功能定义\r对于 lb、lh 来说，我们需要额外增加一个数据扩展模块。这个模块把从数据存储器读出的数据做符号扩展。\n字节使能模块BYTE_EN\r端口说明\r序号 信号名称 方向 描述 1 low2Bit[1:0] I 要取地址的低两位，来自ALU计算结果 2 RD2[31:0] I 输入的 32 位寄存器数据 3 opCode[5:0] I 该阶段指令的opCode 4 en I 向内存写使能信号 5 dataToDM[31:0] O 修改后的向内存写数据 6 byteen[3:0] O 字节使能信号 功能定义\r按字节来访问内存的使能信号和输入数据控制模块\nW级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 xxM I 需要流水的M级数据 4 xxW O W级接收的流水数据 5. W级\r省略控制器和转发输出的选择器\n6. 宏定义和阻塞转发单元\r宏定义\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // for ALU `define ALU_add 4\u0026#39;b000 `define ALU_sub 4\u0026#39;b001 `define ALU_or 4\u0026#39;b010 `define ALU_and 4\u0026#39;b011 `define ALU_xor 4\u0026#39;b100 `define ALU_lui 4\u0026#39;b101 `define ALU_slt 4\u0026#39;b110 `define ALU_sltu 4\u0026#39;b111 // for GRF\u0026#39;s A3 `define REG_T 2\u0026#39;b00 `define REG_D 2\u0026#39;b01 `define REG_31 2\u0026#39;b10 // for GRF\u0026#39;s WD `define FromALURes 2\u0026#39;b00 `define FromMem 2\u0026#39;b01 `define FromPCAdd8 2\u0026#39;b10 `define FromMDRes 2\u0026#39;b11 // for NPC `define NPC_PCPlus4 3\u0026#39;b01 `define NPC_BEQ 3\u0026#39;b10 `define NPC_Jimm26 3\u0026#39;b11 `define NPC_JReg 3\u0026#39;b100 `define NPC_blztal 3\u0026#39;b101 `define NPC_BNE 3\u0026#39;b110 // for TR `define TR_FromE 2\u0026#39;b11 `define TR_FromM 2\u0026#39;b10 `define TR_FromW 2\u0026#39;b01 `define TR_FromOrigin 2\u0026#39;b00 // for MD `define MD_NOP 4\u0026#39;b000 `define MD_MULT 4\u0026#39;b001 `define MD_MULTU 4\u0026#39;b010 `define MD_DIV 4\u0026#39;b011 `define MD_DIVU 4\u0026#39;b100 `define MD_MTLO 4\u0026#39;b101 `define MD_MTHI 4\u0026#39;b110 `define MD_MFLO 4\u0026#39;b111 `define MD_MFHI 4\u0026#39;b1000 阻塞转发单元\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 assign tr_grf_rd1_sel_d = (regWriteE == 1 \u0026amp;\u0026amp; TnewE == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrE) ? `TR_FromE : (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_grf_rd2_sel_d = (regWriteE == 1 \u0026amp;\u0026amp; TnewE == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrE) ? `TR_FromE : (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_alu_src1_sel_e = (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rsAddrE != 0 \u0026amp;\u0026amp; rsAddrE == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rsAddrE != 0 \u0026amp;\u0026amp; rsAddrE == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_alu_src2_sel_e = (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rtAddrE != 0 \u0026amp;\u0026amp; rtAddrE == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rtAddrE != 0 \u0026amp;\u0026amp; rtAddrE == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign STALL = ((Tuse \u0026lt; TnewE) \u0026amp;\u0026amp; ((regWriteE == 1 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrE) || (regWriteE == 1 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrE))) || ((Tuse \u0026lt; TnewM) \u0026amp;\u0026amp; ((regWriteM == 1 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrM) || (regWriteM == 1 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrM))) || (MDOpD != `MD_NOP \u0026amp;\u0026amp; (startE || busy)) ? 1\u0026#39;b1 : 2\u0026#39;b0; hint\rfunction 1 2 3 4 function [data_type] function_name (input_declaration); [function_body] [return statement] endfunction 例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module fun_user ( input a, input b, input c, output [3:0] d, output [3:0] d2 ); function [3:0] dataout; input a; input b; input c; dataout = {a,b,c}; endfunction assign d = dataout(a,b,c); endmodule 处理可能要写寄存器指令的例子\n1 2 3 4 5 6 7 wire E_stall_rs = ((E_lhogez ? (D_rs_addr == 5\u0026#39;d31 || D_rs_addr == E_rt_addr) : (E_GRFA3 == D_rs_addr)) \u0026amp;\u0026amp; D_rs_addr != 0) \u0026amp;\u0026amp; (E_Tnew \u0026gt; D_Tuse_rs); wire E_stall_rt = ((E_lhogez ? (D_rt_addr == 5\u0026#39;d31 || D_rt_addr == E_rt_addr) : (E_GRFA3 == D_rt_addr)) \u0026amp;\u0026amp; D_rt_addr != 0) \u0026amp;\u0026amp; (E_Tnew \u0026gt; D_Tuse_rt); wire M_stall_rs = ((M_lhogez ? (D_rs_addr == 5\u0026#39;d31 || D_rs_addr == M_rt_addr) : (M_GRFA3 == D_rs_addr)) \u0026amp;\u0026amp; D_rs_addr != 0) \u0026amp;\u0026amp; (M_Tnew \u0026gt; D_Tuse_rs); wire M_stall_rt = ((M_lhogez ? (D_rt_addr == 5\u0026#39;d31 || D_rt_addr == M_rt_addr) : (M_GRFA3 == D_rt_addr)) \u0026amp;\u0026amp; D_rt_addr != 0) \u0026amp;\u0026amp; (M_Tnew \u0026gt; D_Tuse_rt); assign Stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt; 二、思考题\r为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n设计模块需要遵循“高内聚低耦合”的原则，也就是尽可能简化每一个模块的复杂度，尽量使他们彼此独立。具体到功能而言，乘除模块的运算无法在一个周期内完成，需要用时序逻辑实现；而之前实现的ALU运算可以在一个周期内完成，实现只需要使用组合逻辑；而且就算不考虑独立的HI、LO寄存器，乘除法部件的计算结果也会来到64位，与ALU行为有较大差异。 独立的HI和LO寄存器更加符合规范，避免了将中间量位宽的最大值从32增加到64；而且增加独立的寄存器更加方便进行存取。\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n二进制乘法可通过同十进制竖式计算乘法的过程进行朴素实现，从乘数的低位开始，每次取一位与被乘数相乘，其乘积作为部分积暂存，乘数的全部有效位都乘完后，再将所有部分积根据对应乘数数位的权值错位累加，得到最后的乘积。但这样的实现会由于产生太多部分积和需要太多加法器导致很大的时延和面积，工业上一般不这么实现；可以使用布斯编码、进位保留加法器、4-2压缩等方法进行优化。\n二进制除法可通过同十进制竖式计算除法的过程进行朴素实现，将被除数移入余数寄存器，然后将余数和除数的最高位对齐（在本P中可忽略这一步，因为都是32位数据；不过毕竟也不用自己实现），然后总是尝试将余数减除数，如果差小于0，就进行回退（加除数）；记录商；将除数右移一位，继续进行减除数的尝试，直到除数为0，否则将商左移一位。\n请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\n我把阻塞信号直接或上(MDOpD != MD_NOP \u0026amp;\u0026amp; (startE || busy))来处理阻塞。\n请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n字节使能指定可以写的字节，相比单一的使能信号可以区分哪些字节是需要写入的，非常直观明了；统一了三个指令的使能方式，方便对接dm模块，用同一种方式可以实现一种类型的所有指令，可扩展性和统一性都很好\n请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n在现在的实现中，实际与DM发生交换的数据仍未按字读取的形式；如果有新增的指令，需要读第一个字的最后一个字节的高四位，读二个字的第一个字节低四位，拼成一个半字，那么此时按字读需要读两次，而按字节读只需1次，此时效率会高。\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\n对转发的来源选择进行抽象，使得实现为每级流水线中都实例化一个转发数据选择器，不需要分别实现多个module；对转发的接收端也可以做同样的抽象。\n在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n相比P5，本次实验需要考虑多两种类型产生的冲突，也就是覆盖对于乘除法寄存器的读和写，分别放在RAW的R部分和W部分即可。 我构造两条连续指令的组，分别对指定寄存器进行写和读，生成随机的测试样例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def seq_ins_2_MD_extension(tmpReg) -\u0026gt; tuple[str, Callable[[], None]]: ret = \u0026#34;\u0026#34; writeOp = random.randint(1, 11) if writeOp == 1: tmpStr, exec1 = ins_add(random_selected_reg(), random_selected_reg(), tmpReg) elif writeOp == 2: tmpStr, exec1 = ins_sub(random_selected_reg(), random_selected_reg(), tmpReg) elif writeOp == 3: tmpStr, exec1 = ins_ori(random_selected_reg(), tmpReg) elif writeOp == 4: tmpStr, exec1 = ins_lui(tmpReg) elif writeOp == 5: tmpStr, exec1 = ins_lw(random_selected_reg(), tmpReg) else: tmpStr, exec1 = random_MD_write(tmpReg) ret += tmpStr exec1() readOp = random.randint(1, 11) if readOp == 1: if random.random() \u0026lt; 0.5: tmpStr, exec2 = ins_add(random_selected_reg(), tmpReg, random_selected_reg()) else: tmpStr, exec2 = ins_add(tmpReg, random_selected_reg(), random_selected_reg()) elif readOp == 2: if random.random() \u0026lt; 0.5: tmpStr, exec2 = ins_sub(random_selected_reg(), tmpReg, random_selected_reg()) else: tmpStr, exec2 = ins_sub(tmpReg, random_selected_reg(), random_selected_reg()) elif readOp == 3: tmpStr, exec2 = ins_ori(tmpReg, random_selected_reg()) elif readOp == 4: tmpStr, exec2 = ins_sw(tmpReg, random_selected_reg()) elif readOp == 5: # readOp == 5: tmpStr, exec2 = ins_lw(tmpReg, random_selected_reg()) else: tmpStr, exec2 = random_MD_read(tmpReg) ret += tmpStr exec2() def execute(): exec1() exec2() return ret, execute 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n主要是针对RAW进行构造数据冒险序列，第一条为写指定寄存器的随机指令，第二条为读取指定寄存器的随机指令，随机部分保证指定寄存器不在被随机的集合中，由此可以达到随机的效果；曾经想过构造完全随机生成的测试样例，但仍然需要处理生成数据可能不合法的情况，而且需要极大的数据量来覆盖冲突情况。对跳转类型指令构造特殊结构来测试对于转发和阻塞的覆盖情况，但这部分还做得不够好，需要思考更复杂的情况来提高覆盖率。\n三、测试方案\r使用课程组提供的测试数据和Mars进行对拍。 自行构造数据，参考了学长的评测机搭建思路，还在迭代改进中 ","date":"2023-11-19T00:00:00Z","permalink":"http://localhost:1313/p/co-p6-doc/","title":"CO | P6 - Verilog 流水线 CPU 设计文档"},{"content":"计组实验 P5 设计文档\n优化思路：lui提前处理，TnewE=0；对sw区分Tuse\n处理器应支持如下指令集：{ add, sub, ori, lw, sw, beq, lui, jal, jr, nop }\n零、教程摘录\r从状态机的角度分析，P5 阶段的 CPU 出现功能错误只有这些可能：指令执行流错误（ PC 错误）；写入 GRF 错误；写入 DM 错误。 五级流水线：Fetch，Decode，Execute，Memory，Writeback 流水数据的选择：一般而言，我们需要流水的数据只有一个衡量标准，就是我们在其后的流水阶段中需不需要这个数据，比如说 ALU 的计算结果，有的会被写回寄存器文件中，所以我们需要流水这个数据，而 rs 对应的寄存器值，在 M 级和 W 级并没有用到，所以就可以不再流水（仅一般情况）。当一个数据被选择成为了流水数据，那么其在 CPU 中就可能存在多个值。比如 E, M, W 级均会有 ALU 的计算结果（三者并不相同），在编程的时候应当使用流水阶段名前缀将其区分开。 1. 冒险\r结构冒险：不同指令同时需要使用同一资源。本实验采用哈佛体系结构，需要考虑的结构冒险为寄存器文件需要在 D 级和 W 级同时被使用（读写）时并且读和写的寄存器为同一个寄存器时。 控制冒险：分支指令（如 beq ）的判断结果会影响接下来指令的执行流。在判断结果产生之前，我们无法预测分支是否会发生。然而，此时流水线还会继续取指，让后续指令进入流水线。这时就有可能导致错误的产生，即不该被执行的指令进入到了指令的执行流中。 数据冒险：后面指令需求的数据，正好就是前面指令供给的数据，而后面指令在需要使用数据时，前面供给的数据还没有存入寄存器堆，从而导致后面的指令不能正常地读取到正确的数据。 解决方法：尽量转发（重定向数据），否则阻塞 要求大家所有转发数据都来源于流水寄存器而不能是功能部件 2. 流水线实现\r阻塞\r课程组要求阻塞是指将指令阻塞在 D 级。当一个指令到达 D 级后，我们需要将它的 $T_{use}​$ 值与后面每一级的 $T_{new}​$​ 进行比较（当然还有 A 值的校验），当 $T_{use}​$\u0026lt; $T_{new}​$时，我们需要阻塞流水线。 阻塞的实现：（1）冻结PC的值；（2）冻结D级流水线寄存器的值；（3）清零E级流水线寄存器的值（等价于插入nop指令） 注意复位信号和阻塞信号的优先级问题。仔细设计信号的优先级来保证流水线的正确性。 转发\r为了实现转发，我们需要两种多路选择器 MUX，分别对应转发的供给者和需求者。\n控制器\r解决冒险需要进行 AT 值的比较判断，并需要根据判断的结果产生特定的控制信息。这些功能要求我们丰富我们的控制器，使其可以支持这些功能。控制器需要产生的信号包括但不限于冻结信号，刷新信号，供给者选择器信号，需求者选择器信号等。\n转发优先级：选择流水线中靠前的“新鲜”的数据进行转发 rt域有效性：有些指令的 rt 域不是用来表示读寄存器编号的，但不需要对它们进行特判：即使我们转发了相应的数据，也不会影响流水线的正确性，因此无需特判。\n延迟槽\r延迟槽就是所有跳转类指令，不论是条件转移满足转移条件（即beq等）还是非条件转移（即j，jr，jal等），它的下一条指令都被写mips汇编程序者写成了一条程序中必须会完成的指令，必须进入流水线，完成所有的步骤。换言之，对于条件转移类指令，无论是否满足转移条件，它的下一条指令都需要执行；对于非条件转移类指令，它的下一条指令也必须执行，所以，在F级不需要设置NPC模块，只需要ADD4模块，而在D级设置NPC模块，它的PC+8指令才是转移后的指令。总结来讲，支持延迟槽就是编写mips汇编语言的人用他们的智慧给搭建流水线CPU的人提供便利。\n一、设计草稿\r支持的指令\radd, sub, ori, lui, lw, sw, beq, jal, jr, nop\nR型\radd: 000000 rs rt rd 00000 100000 sub: 000000 rs rt rd 00000 100010 jr: 000000 rs 00_0000_0000 00000 001000 I型\rbeq: 000100 rs rt offset(imm) lui: 001111 00000 rt imm 0 1 0 1 0 0 0 Shift ori: 001101 rs rt imm lw: 100011 base rt offset(imm) sw: 101011 base rt offset(imm) J型\rjal: 000011 imm26 1. F级\r取指令单元IFU\r含有指令存储器IM和程序计数器PC；IM 容量为 16KiB（4096 × 32bit）\n端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效，置pc为0x0000_3000 2 clk I 时钟信号 3 stallF I 阻塞控制信号 4 pcNext[31:0] I 下一条指令的地址 5 pc[31:0] O 当前指令地址 6 Instr[31:0] O 将要执行的指令 功能定义\r序号 功能 描述 1 复位 同步复位，置pc为0x00003000 2 更新 在时钟上升沿，更新pc的值为pcNext 3 输出 输出当前指令地址对应指令内容 D级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 stallD I 阻塞控制信号 4 xxF I 需要流水的F级数据 5 xxD O D级接收的流水数据 2. D级\r控制器CTRL\r分布式译码形式的控制器，实例化为ctrl_d\n端口说明\r序号 信号名称 方向 描述 1 func[5:0] I 指令的5-0位，对R型指令进行进一步判别 2 Opcode[5:0] I 指令的31-26位 3 targetRegSel[1:0] O 写入寄存器指示信号，控制写入rt、rd、31 4 aluSrc O ALU输入选择信号，高电平时为ImmExtended，低电平时为RD2 5 mem2Reg[1:0] O 写入寄存器堆数据选择信号，控制从DM、aluResult、PC+8写入 6 regWrite O 高电平时寄存器堆写入使能，低电平时寄存器堆不可写入 7 memWrite O 高电平时DM写入使能，低电平时DM不可写入 8 NPCop[2:0] O 控制NPC行为 9 ExtOp O 高电平时EXT进行符号拓展，低电平时EXT进行0拓展 10 ALUop[3:0] O ALU运算控制信号 11 Tuse O 指示当前指令的Tuse，若有两个不同的值，输出较小值 12 TnewE O 指示当前指令在E级的Tnew 功能定义\r根据func和Opcode解析指令类型，进而构建数据通路\n控制信号对应\rIns add sub ori lui lw sw beq jal jr func 10 0000 10 0010 x x x x x x 001000 op 00 0000 00 0000 00 1101 00 1111 10 0011 10 1011 00 0100 000011 000000 TargetReg 1 1 0 0 0 x x 2(31) x ALUSrc 0 0 1 1 1 1 0 x x Mem2Reg 0 0 0 0 1 x x 2(PC+8) x RegWrite 1 1 1 1 1 0 0 1 0 MemWrite 0 0 0 0 0 1 0 0 0 Branch 0 0 0 0 0 0 1 0 0 JImm26 0 0 0 0 0 0 0 1 0 JReg 0 0 0 0 0 0 0 0 1 ExtOp x x 0 0 1 1 1 x x ALUop add sub or shift add add sub x x Tuse 1 1 1 1 1 1 0 x 0 TnewE 1 1 1 1 2 x x 0 x 次地址计算单元NPC\r端口说明\r序号 信号名称 方向 描述 1 pcF[31:0] I F级指令地址 2 pcD[31:0] I D级指令地址 3 offset[15:0] I 16位立即数 4 imm26[25:0] I j、jal指令使用的26位立即数 5 NPCop[2:0] I NPC行为控制信号 6 TR_GRF_RD1[31:0] I 寄存器rs的值，可用于beq相等判断和jr指令使用 7 TR_GRF_RD2[31:0] I 寄存器rt的值，可用于beq相等判断 8 NPCoutput[31:0] O 下一条指令的地址 功能定义\r序号 功能 描述 1 输出pcNext 输出pcNext D级转发接收端选择器TR_GRF_Data\r分别实例化为tr_grf_d1，tr_grf_d2\n端口说明\r序号 信号名称 方向 描述 1 grfData[31:0] I 寄存器数据 2 trDataE[31:0] I E级发来的转发数据 2 trDataM[31:0] I M级发来的转发数据 2 trDataW[31:0] I W级发来的转发数据 5 grfOutTrOp[1:0] I 选择器行为控制信号 8 trData[31:0] O 转发出去的数据 寄存器堆GRF\r端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 WE I 写使能信号，高电平有效 4 A1[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD1 5 A2[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD2 6 A3[4:0] I 5位地址输入信号，指定寄存器位置，将WD数据写入到寄存器 7 WD [31:0] I 32位写入数据内容 8 RD1 [31:0] O 输出A1指定的寄存器的32位数据 9 RD2 [31:0] O 输出A2指定的寄存器的32位数据 功能定义\r序号 功能 描述 1 同步复位 reset有效时同步复位所有寄存器 2 读出数据 将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出 3 写入数据 当WE有效且clk上升沿来临时将WD数据写入到A3指定的寄存器 扩展单元EXT\r端口说明\r序号 信号名称 方向 描述 1 IN[15:0] I 要扩展的16位立即数 2 ExtOp I 扩展方式控制信号，高电平时进行符号拓展，低电平时进行零拓展 3 OUT[31:0] O 扩展结果 功能定义\r根据ExtOp信号对立即数进行对应拓展\nE级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效，输入为STALL 2 clk I 时钟信号 3 xxD I 需要流水的D级数据 4 xxE O E级接收的流水数据 3. E级\r省略E级控制器\nE级转发接收端选择器TR_ALU_SRC\r分别实例化为tr_alu_src1，tr_alu_src2\n端口说明\r序号 信号名称 方向 描述 1 TR_GRF_RD[31:0] I 寄存器数据 2 trDataM[31:0] I M级发来的转发数据 2 trDataW[31:0] I W级发来的转发数据 5 trSel[1:0] I 选择器行为控制信号 8 aluSrc[31:0] O 转发出去的数据 寄存器写入地址选择器WR_MUX\r序号 信号名称 方向 描述 1 rt[4:0] I rt寄存器地址 2 rd[4:0] I rd寄存器地址 2 sel[1:0] I 选择器行为控制信号 8 writeRegAddr[4:0] O 寄存器写入地址 ALU输入源2选择器ALUSRC_MUX\r序号 信号名称 方向 描述 1 rtData[31:0] I rt寄存器数据 2 immExtended32[31:0] I 扩展后的立即数 2 aluSrcSel I 选择器行为控制信号 8 src2[31:0] O alu输入源数据 算数运算单元ALU\r端口说明\r序号 信号名称 方向 描述 1 src1[31:0] I ALU计算的第一个操作数 2 src2[31:0] I ALU计算的第二个操作数 3 aluop[3:0] I ALU功能选择信号，MIPS-C指令集需要9种运算 4 res [31:0] O 输出计算结果 功能定义\r支持无符号加、无符号减、或、与、异或、src2左移16位，aluop见def.v\n序号 功能 ALUop 描述 1 无符号加 00 res = src1 + src2 2 无符号减 01 res = src1 - src2 3 或 10 res = src1 | src2 4 src2左移16位 11 res = src2 \u0026laquo; 0x10 E级转发输出端选择器WRD_MUX\r序号 信号名称 方向 描述 1 aluOut[31:0] I alu运算结果 2 dmDataOut[31:0] I DM读出的数据 2 pc[31:0] I 当前指令的地址 5 trSel[1:0] I 选择器行为控制信号，来源为mem2Reg 8 aluSrc[31:0] O 转发出去的数据 M级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 xxE I 需要流水的E级数据 4 xxM O M级接收的流水数据 4. M级\r省略控制器和转发输出的选择器\n数据存储器DM\rDM 容量为 12KiB（3072 × 32bit）\n端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 MemWrite I 写使能信号，高电平有效 4 MemAddr[11:0] I 12位地址输入信号，指定内存位置 5 DataWrite[31:0] I 32位写入数据内容 6 DataRead[31:0] O 32位读出数据内容 功能定义\r序号 功能 描述 1 复位 同步复位，清空所有数据 2 更新 在时钟上升沿且写使能信号有效时，更新指定地址的内容为指定数据 3 输出 输出当前内存地址对应数据内容 W级流水线寄存器\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 xxM I 需要流水的M级数据 4 xxW O W级接收的流水数据 5. W级\r省略控制器和转发输出的选择器\n6. 宏定义和阻塞转发单元\r宏定义\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // for ALU `define ALU_add 4\u0026#39;b000 `define ALU_sub 4\u0026#39;b001 `define ALU_or 4\u0026#39;b010 `define ALU_and 4\u0026#39;b011 `define ALU_xor 4\u0026#39;b100 `define ALU_lui 4\u0026#39;b101 // for GRF\u0026#39;s A3 `define REG_T 2\u0026#39;b00 `define REG_D 2\u0026#39;b01 `define REG_31 2\u0026#39;b10 // for GRF\u0026#39;s WD `define FromALURes 2\u0026#39;b00 `define FromMem 2\u0026#39;b01 `define FromPCAdd8 2\u0026#39;b10 // for NPC `define NPC_PCPlus4 3\u0026#39;b00 `define NPC_Branch 3\u0026#39;b01 `define NPC_Jimm26 3\u0026#39;b10 `define NPC_JReg 3\u0026#39;b11 // for TR `define TR_FromE 2\u0026#39;b11 `define TR_FromM 2\u0026#39;b10 `define TR_FromW 2\u0026#39;b01 `define TR_FromOrigin 2\u0026#39;b00 阻塞转发单元\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 assign tr_grf_rd1_sel_d = (regWriteE == 1 \u0026amp;\u0026amp; TnewE == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrE) ? `TR_FromE : (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_grf_rd2_sel_d = (regWriteE == 1 \u0026amp;\u0026amp; TnewE == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrE) ? `TR_FromE : (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_alu_src1_sel_e = (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rsAddrE != 0 \u0026amp;\u0026amp; rsAddrE == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rsAddrE != 0 \u0026amp;\u0026amp; rsAddrE == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign tr_alu_src2_sel_e = (regWriteM == 1 \u0026amp;\u0026amp; TnewM == 0 \u0026amp;\u0026amp; rtAddrE != 0 \u0026amp;\u0026amp; rtAddrE == writeRegAddrM) ? `TR_FromM : (regWriteW == 1 \u0026amp;\u0026amp; TnewW == 0 \u0026amp;\u0026amp; rtAddrE != 0 \u0026amp;\u0026amp; rtAddrE == writeRegAddrW) ? `TR_FromW : `TR_FromOrigin; assign STALL = ((Tuse \u0026lt; TnewE) \u0026amp;\u0026amp; ((regWriteE == 1 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrE) || (regWriteE == 1 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrE))) || ((Tuse \u0026lt; TnewM) \u0026amp;\u0026amp; ((regWriteM == 1 \u0026amp;\u0026amp; rsAddrD != 0 \u0026amp;\u0026amp; rsAddrD == writeRegAddrM) || (regWriteM == 1 \u0026amp;\u0026amp; rtAddrD != 0 \u0026amp;\u0026amp; rtAddrD == writeRegAddrM))) ? 1\u0026#39;b1 : 2\u0026#39;b0; hint\rfunction 1 2 3 4 function [data_type] function_name (input_declaration); [function_body] [return statement] endfunction 例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module fun_user ( input a, input b, input c, output [3:0] d, output [3:0] d2 ); function [3:0] dataout; input a; input b; input c; dataout = {a,b,c}; endfunction assign d = dataout(a,b,c); endmodule 二、思考题\r我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。\n以beq指令为例，提前分支判断导致其Tuse为0，由于Tuse \u0026lt; Tnew时需要进行阻塞，而如add、ori、lw等指令TnewE都大于0，非常容易组合产生有阻塞的指令序列，因此并非总能提高效率。\n1 2 3 4 5 ... lw $t0, 0($s0) beq $t0, $t1, label ... label: ... 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？\n考虑延迟槽，跳转指令后的下一条指令A一定随之执行，其地址为pc+4；如果写回数据为pc+4，则调用jr等指令时再次跳转到pc+4，A又要被执行一次，与需求情况不符。\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？\n从功能部件转发，反而导致对应级的执行总延迟增加，使得流水线的最小时钟周期可能变长，降低效率；一开始以为有数据不稳定的问题，例如功能部件的执行延迟可能低于转发逻辑的执行延迟；但考虑到只要时钟周期能够保证就不存在这种问题\n我们为什么要使用 GPR 内部转发？该如何实现？\nW级要写入的数据可能与D级要读出的数据发生冲突，采用内部转发使得就算时钟上升沿未到来，D级读出的数据也是正确的；我的实现保证regs[0]读出数据始终为0。\n1 2 assign RD1 = (A1 == A3 \u0026amp;\u0026amp; WE == 1) ? WD : regs[A1]; assign RD2 = (A2 == A3 \u0026amp;\u0026amp; WE == 1) ? WD : regs[A2]; 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？\n需求者：GRF读出数据、ALU来源数据 供给者：E级PC、M级ALURes、M级PC、W级dmDataOut、W级ALURes、W级PC 转发数据通路：to D from E M W; to E from M W.\n在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。\n计算指令：更改CTRL和ALU，不修改转发逻辑 跳转指令：条件跳转+条件写，在NPC增加跳转判断，在D级进行写判断，扩展regWriteAddr的选择、转发供给端的选择 访存指令：感觉最可能出Load型指令，在W级增加条件判断，TnewE一般为2；如果对目标寄存器地址有影响，要增加选择器。\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。\n我的译码方式为分布式译码。这种方法比较灵活，可以降低需要流水的信号量；但是需要实例化多个控制器，复杂性会有所增加。\n三、测试方案\r使用课程组提供的测试数据和Mars进行对拍。 自行构造数据，参考了学长的评测机搭建思路，还在迭代改进中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 lui $0, 0xf3e ori $0, $0, 0x3256 lui $1, 0xeffc ori $1, $1, 0xe15e lui $2, 0xedd2 ori $2, $2, 0x9476 lui $3, 0x3101 ori $3, $3, 0x99c7 lui $4, 0x1a28 ori $4, $4, 0xc4e3 lui $5, 0x8e4a ori $5, $5, 0x8477 lui $6, 0x414c ori $6, $6, 0xff33 lui $7, 0xed44 ori $7, $7, 0x5ab7 lui $8, 0x84e0 ori $8, $8, 0x93ee lui $9, 0x4b20 ori $9, $9, 0x80 lui $10, 0x821e ori $10, $10, 0xeb06 lui $11, 0x64a5 ori $11, $11, 0x264 lui $12, 0xd7b ori $12, $12, 0x7ce0 lui $13, 0xdf5d ori $13, $13, 0xa82c lui $14, 0xcab9 ori $14, $14, 0x7316 lui $15, 0xc045 ori $15, $15, 0x5cda lui $16, 0x359a ori $16, $16, 0xfb82 lui $17, 0x21f3 ori $17, $17, 0x8d32 lui $18, 0x330a ori $18, $18, 0xf0fe lui $19, 0xeaa5 ori $19, $19, 0xa70a lui $20, 0x86f ori $20, $20, 0x199f lui $21, 0xbfc4 ori $21, $21, 0x77e6 lui $22, 0x446c ori $22, $22, 0x4f02 lui $23, 0x513a ori $23, $23, 0xa2d8 lui $24, 0xbcba ori $24, $24, 0xa05 lui $25, 0xac65 ori $25, $25, 0xf0f0 lui $26, 0xcb68 ori $26, $26, 0x7cdc lui $27, 0xd901 ori $27, $27, 0xca0a lui $28, 0x84e2 ori $28, $28, 0xbdcd lui $29, 0x8473 ori $29, $29, 0x9ced lui $30, 0x12a0 ori $30, $30, 0x901f lui $31, 0x119a ori $31, $31, 0xedcf lui $19, 0xb672 lui $19, 0x0 ori $19, $19, 0xf34 sw $8, 1288($19) sub $9, $16, $1 lui $9, 0x0 ori $9, $9, 0x7260 sw $17, -21852($9) add $10, $20, $14 ori $31, $10, 0x8dc ori $2, $5, 0xb358 ori $24, $2, 0xf67b ori $18, $28, 0x7722 ori $26, $18, 0xd9c0 lui $27, 0xa1f9 lui $27, 0xffff ori $27, $27, 0xfb70 lw $18, 1272($27) lui $9, 0x3405 lui $9, 0x0 ori $9, $9, 0x2306 sw $10, -8450($9) lui $15, 0x879a lui $15, 0xffff ori $15, $15, 0xee09 lw $18, 7651($15) add $2, $0, $8 ori $5, $2, 0x3e48 lw $8, 10172($18) sub $27, $8, $16 add $20, $17, $20 sub $14, $20, $27 sub $1, $29, $10 lui $1, 0xffff ori $1, $1, 0xfe46 lw $26, 2894($1) ori $14, $18, 0x6052 sw $16, -20594($14) lw $2, 1036($26) lw $16, 11328($2) add $4, $15, $2 lw $2, 11287($4) lui $0, 0x9d4 add $9, $26, $0 add $30, $5, $14 add $12, $30, $17 lw $28, -23578($14) ori $13, $28, 0x453d lui $27, 0xffff ori $27, $27, 0xee6b lw $19, 16273($27) ori $13, $19, 0xe47a lw $7, 2264($9) sw $30, 6960($7) sub $14, $5, $5 ori $13, $14, 0xbbab ori $6, $7, 0x77d7 ori $2, $6, 0x4567 sub $9, $11, $3 sub $11, $16, $9 sub $23, $26, $0 sub $0, $23, $19 add $21, $20, $6 lui $21, 0xffff ori $21, $21, 0xdf61 sw $30, 9535($21) add $31, $2, $6 lui $31, 0x0 ori $31, $31, 0x28d4 sw $0, -7256($31) lui $19, 0x236d lui $19, 0x0 ori $19, $19, 0x4c30 sw $31, -12408($19) sub $8, $25, $25 sub $14, $8, $21 add $2, $0, $23 sw $11, 6292($2) sub $26, $15, $22 lui $26, 0xffff ori $26, $26, 0xdc99 sw $30, 9203($26) ori $15, $10, 0xf39a add $7, $15, $11 lw $29, 16775($4) add $4, $29, $3 ori $30, $4, 0x4671 lui $30, 0x0 ori $30, $30, 0xdcb sw $15, 4197($30) lui $21, 0x9d71 ori $21, $21, 0xa95c ori $10, $14, 0x30e add $14, $10, $23 ori $16, $18, 0xc89d lui $16, 0x0 ori $16, $16, 0x1c90 sw $14, -3088($16) lui $9, 0x0 ori $9, $9, 0x4084 lw $16, -4756($9) lw $27, 9268($16) add $1, $24, $27 lui $1, 0xffff ori $1, $1, 0xc27c sw $14, 24332($1) sub $2, $7, $0 add $14, $2, $3 lui $6, 0x4438 lui $6, 0x0 ori $6, $6, 0x57ed lw $6, -19161($6) lui $21, 0x0 ori $21, $21, 0x8bbb lw $8, -30023($21) add $20, $12, $8 lw $13, 12044($23) sw $8, 2608($13) add $27, $18, $2 lui $27, 0x0 ori $27, $27, 0x82e6 sw $5, -32138($27) ori $21, $4, 0xf7a8 add $3, $21, $29 ori $27, $6, 0x5265 lw $12, -12269($27) lw $25, 6652($28) lw $25, 5164($25) sub $0, $1, $5 sub $31, $0, $0 ori $6, $6, 0x8e4f ori $7, $6, 0xdf1a lui $14, 0x0 ori $14, $14, 0x80f5 lw $20, -26157($14) sub $23, $20, $15 ori $1, $29, 0x8cc7 sub $25, $25, $1 lui $25, 0x0 ori $25, $25, 0x7349 lw $23, -25445($25) sw $5, 10556($23) add $27, $11, $14 lui $27, 0xffff ori $27, $27, 0xc6da sw $3, 15294($27) lui $21, 0x0 ori $21, $21, 0x5277 lw $17, -20019($21) sw $10, 4848($17) lui $5, 0x0 ori $5, $5, 0x1e3c lw $26, -2648($5) sw $8, 7872($26) lw $12, -3168($5) lw $30, 9028($12) sub $30, $0, $16 lw $9, 5424($30) add $6, $1, $25 ori $8, $6, 0x85db ori $11, $9, 0xc1dc lui $11, 0xffff ori $11, $11, 0xc67b lw $16, 25045($11) lw $1, 4176($29) sw $10, 3932($1) lui $8, 0x0 ori $8, $8, 0x3837 lw $3, -13239($8) ori $20, $3, 0x204f lui $9, 0x49ec ori $10, $9, 0x1908 sub $28, $10, $22 lui $28, 0x0 ori $28, $28, 0x5d96 sw $1, -23914($28) add $14, $14, $14 lui $14, 0x0 ori $14, $14, 0xc26 sw $30, 8546($14) lw $15, 1880($29) sw $2, 11704($15) lui $6, 0x0 ori $6, $6, 0x3adc lw $26, -13384($6) ori $20, $26, 0x57f5 sub $2, $13, $10 lui $2, 0xffff ori $2, $2, 0xf4aa sw $3, 9282($2) ori $4, $9, 0x1fc0 lui $4, 0x0 ori $4, $4, 0x79af sw $31, -28999($4) sub $21, $6, $9 sub $18, $21, $23 lui $30, 0x446b sub $26, $30, $30 ori $26, $29, 0xad7c add $23, $26, $18 sub $3, $18, $29 lui $3, 0x0 ori $3, $3, 0x19a lw $10, 3938($3) lw $8, 24005($11) ori $18, $8, 0x7542 lw $10, 7486($3) sub $21, $11, $10 add $19, $26, $23 sub $24, $20, $19 sub $10, $6, $29 sw $5, -13348($10) lw $23, 7464($0) sw $24, 2344($23) ori $6, $0, 0xdc54 sub $30, $27, $6 lw $16, -22150($18) sub $1, $25, $16 ori $28, $11, 0x4188 ori $14, $28, 0x4833 ori $31, $28, 0x7ab6 lw $25, 9913($31) add $5, $3, $27 add $13, $5, $23 lui $4, 0x14d3 add $17, $4, $23 lw $28, 22305($28) sw $11, 8660($28) lui $9, 0x7113 lui $9, 0x0 ori $9, $9, 0x6a32 lw $15, -16134($9) sub $29, $20, $15 ori $7, $29, 0x882 sub $7, $26, $22 lui $7, 0x0 ori $7, $7, 0x769 lw $12, 8615($7) add $26, $27, $3 ori $7, $26, 0x95d2 ori $22, $9, 0x2bf5 sub $3, $22, $22 ori $31, $13, 0x83ab ori $3, $31, 0x80fe add $3, $21, $19 sub $21, $25, $3 lw $31, 9738($7) ori $11, $31, 0xf617 lw $6, 13722($2) add $15, $6, $24 lw $1, 3640($12) sw $18, 6040($1) sub $1, $5, $27 sw $19, 4058($1) ori $18, $18, 0x9824 add $22, $5, $18 ori $14, $1, 0x3e72 sub $22, $14, $4 lui $28, 0x1272 lui $28, 0xffff ori $28, $28, 0xf9ba lw $3, 5418($28) lw $4, -23982($9) add $1, $29, $4 ori $27, $21, 0x5ed1 sub $19, $21, $27 ori $31, $23, 0x4136 lw $9, -16370($31) ori $15, $0, 0x0 label_loop0_start: add $25, $4, $13 ori $18, $26, 0x2818 ori $21, $4, 0x541d ori $9, $8, 0x39ea add $13, $5, $11 sub $17, $10, $22 lui $11, 0x6e7 sub $17, $5, $26 lui $28, 0x3b1f add $10, $7, $18 ori $2, $0, 0x1 add $15, $2, $15 ori $2, $0, 0x3 beq $2, $15, label_loop0_end ori $20, $22, 0xa747 jal label_loop0_start sub $25, $23, $27 label_loop0_end: ori $30, $0, 0x0 label_loop1_start: add $16, $14, $8 ori $19, $8, 0x5009 sub $9, $26, $27 sub $3, $26, $8 ori $16, $18, 0xda38 lui $17, 0x94c5 sub $2, $21, $26 sub $28, $21, $28 add $18, $18, $0 ori $29, $15, 0x4bfa ori $4, $0, 0x1 add $30, $4, $30 ori $4, $0, 0x3 beq $4, $30, label_loop1_end ori $28, $7, 0x382c jal label_loop1_start lui $0, 0x21ea label_loop1_end: ori $7, $0, 0x0 label_loop2_start: add $20, $19, $23 add $3, $26, $17 lui $2, 0x83c7 sub $5, $4, $17 lui $10, 0x4233 lui $3, 0xffa1 add $1, $28, $20 add $20, $27, $29 sub $28, $20, $22 add $18, $25, $26 ori $8, $0, 0x1 add $7, $8, $7 ori $8, $0, 0x3 beq $8, $7, label_loop2_end add $10, $29, $14 jal label_loop2_start sub $19, $4, $24 label_loop2_end: ori $4, $0, 0x0 label_loop3_start: add $23, $0, $27 add $3, $3, $18 lui $16, 0x4e74 lui $30, 0x3825 lui $7, 0x7554 ori $15, $10, 0xbcb9 sub $17, $3, $28 add $14, $26, $29 lui $28, 0xafe6 sub $7, $16, $27 ori $5, $0, 0x1 add $4, $5, $4 ori $5, $0, 0x3 beq $5, $4, label_loop3_end add $1, $23, $13 jal label_loop3_start ori $16, $26, 0xdcac label_loop3_end: ori $24, $0, 0x0 label_loop4_start: sub $11, $29, $4 lui $5, 0x1d48 ori $17, $22, 0xce59 ori $9, $11, 0xa555 lui $21, 0x8d5e sub $26, $8, $27 ori $23, $28, 0xcd62 add $17, $20, $15 lui $27, 0x4170 ori $13, $0, 0xd945 ori $12, $0, 0x1 add $24, $12, $24 ori $12, $0, 0x3 beq $12, $24, label_loop4_end lui $22, 0x2f5d jal label_loop4_start lui $3, 0x6f3 label_loop4_end: ori $26, $0, 0x0 label_loop5_start: ori $2, $13, 0x3771 sub $10, $18, $8 add $16, $25, $15 sub $15, $7, $27 ori $21, $16, 0x95a4 add $8, $10, $12 lui $13, 0x9590 add $3, $0, $0 ori $13, $11, 0x73f1 ori $25, $25, 0x311c ori $24, $0, 0x1 add $26, $24, $26 ori $24, $0, 0x3 beq $24, $26, label_loop5_end add $27, $13, $15 jal label_loop5_start lui $0, 0x92ad label_loop5_end: ori $20, $0, 0x0 label_loop6_start: ori $4, $24, 0x523c lui $1, 0x145b ori $29, $29, 0x6507 sub $0, $5, $28 ori $6, $1, 0x4fb3 ori $12, $13, 0x6528 ori $7, $18, 0x31d9 lui $3, 0xe40e add $3, $12, $18 ori $7, $6, 0xb59c ori $10, $0, 0x1 add $20, $10, $20 ori $10, $0, 0x3 beq $10, $20, label_loop6_end sub $18, $5, $25 jal label_loop6_start sub $3, $7, $27 label_loop6_end: ori $15, $0, 0x0 label_loop7_start: lui $20, 0x5d9 sub $18, $22, $13 ori $26, $24, 0x2d06 add $3, $25, $4 sub $17, $17, $2 lui $7, 0x2bca sub $21, $28, $0 add $26, $12, $14 add $16, $18, $19 ori $23, $24, 0xfe57 ori $5, $0, 0x1 add $15, $5, $15 ori $5, $0, 0x3 beq $5, $15, label_loop7_end add $17, $28, $29 jal label_loop7_start add $4, $11, $11 label_loop7_end: ori $11, $0, 0x0 label_loop8_start: add $7, $12, $9 ori $3, $30, 0xb2a2 ori $14, $23, 0xa143 add $28, $29, $8 ori $16, $2, 0x80bc sub $25, $17, $9 lui $30, 0xb919 add $28, $17, $12 ori $7, $24, 0xaf9a ori $26, $17, 0x23b0 ori $1, $0, 0x1 add $11, $1, $11 ori $1, $0, 0x3 beq $1, $11, label_loop8_end ori $20, $17, 0x222b jal label_loop8_start sub $10, $10, $16 label_loop8_end: ori $26, $0, 0x0 label_loop9_start: ori $21, $3, 0xef24 lui $17, 0x7a3a lui $13, 0x4831 add $7, $22, $7 add $6, $15, $9 add $23, $6, $8 lui $21, 0xd67c add $25, $14, $2 ori $29, $21, 0x657c ori $11, $22, 0xcbfb ori $12, $0, 0x1 add $26, $12, $26 ori $12, $0, 0x3 beq $12, $26, label_loop9_end lui $3, 0x9097 jal label_loop9_start lui $21, 0xa88 label_loop9_end: ori $24, $0, 0x0 label_loop10_start: add $30, $16, $27 ori $13, $13, 0x5515 lui $27, 0x510 lui $25, 0xceea sub $0, $10, $10 ori $10, $13, 0x7c3e ori $13, $19, 0x596b add $25, $13, $5 ori $17, $17, 0x88d6 lui $15, 0xf460 ori $20, $0, 0x1 add $24, $20, $24 ori $20, $0, 0x3 beq $20, $24, label_loop10_end lui $27, 0x5b72 jal label_loop10_start add $4, $23, $29 label_loop10_end: ori $15, $0, 0x0 label_loop11_start: ori $20, $22, 0xe426 ori $8, $27, 0xf9c7 lui $3, 0x6cbe lui $11, 0xa48b add $6, $18, $7 sub $10, $3, $7 ori $12, $10, 0x19d4 add $22, $7, $29 lui $12, 0xd58f lui $16, 0xa752 ori $28, $0, 0x1 add $15, $28, $15 ori $28, $0, 0x3 beq $28, $15, label_loop11_end add $25, $26, $17 jal label_loop11_start sub $13, $9, $1 label_loop11_end: ori $24, $0, 0x0 label_loop12_start: lui $27, 0xf346 add $22, $18, $25 ori $3, $0, 0xa0c2 lui $2, 0x3836 ori $19, $21, 0xaa85 ori $1, $28, 0xb360 sub $4, $11, $21 sub $8, $27, $28 lui $30, 0x921c sub $23, $4, $17 ori $9, $0, 0x1 add $24, $9, $24 ori $9, $0, 0x3 beq $9, $24, label_loop12_end sub $1, $30, $13 jal label_loop12_start ori $21, $28, 0x212f label_loop12_end: ori $14, $0, 0x0 label_loop13_start: sub $10, $23, $6 sub $1, $1, $24 lui $24, 0x5b3e lui $26, 0x6b57 ori $1, $23, 0x7c5d add $13, $0, $4 add $2, $15, $18 sub $15, $30, $15 ori $10, $10, 0x29 sub $27, $26, $19 ori $28, $0, 0x1 add $14, $28, $14 ori $28, $0, 0x3 beq $28, $14, label_loop13_end sub $5, $24, $7 jal label_loop13_start add $23, $19, $27 label_loop13_end: ori $17, $0, 0x0 label_loop14_start: ori $5, $26, 0xffd8 add $6, $20, $3 ori $13, $9, 0xf87f ori $29, $19, 0xed0c ori $28, $14, 0xd79e add $10, $30, $5 sub $25, $7, $3 sub $12, $13, $13 add $18, $27, $9 lui $3, 0x771a ori $22, $0, 0x1 add $17, $22, $17 ori $22, $0, 0x3 beq $22, $17, label_loop14_end add $6, $30, $8 jal label_loop14_start ori $21, $8, 0x110e label_loop14_end: ori $22, $0, 0x0 label_loop15_start: sub $5, $9, $29 add $26, $12, $13 lui $21, 0x9f99 sub $13, $16, $21 ori $7, $28, 0x3abd add $2, $6, $4 sub $20, $21, $25 sub $26, $3, $10 sub $9, $18, $30 sub $30, $6, $1 ori $14, $0, 0x1 add $22, $14, $22 ori $14, $0, 0x3 beq $14, $22, label_loop15_end sub $7, $23, $7 jal label_loop15_start lui $26, 0xc44 label_loop15_end: ori $16, $0, 0x0 label_loop16_start: lui $26, 0x199c sub $27, $25, $27 ori $21, $4, 0xcd10 sub $25, $4, $12 ori $28, $2, 0xae2a add $18, $28, $9 lui $29, 0xa2fc ori $30, $10, 0x203d add $27, $25, $28 sub $29, $4, $30 ori $1, $0, 0x1 add $16, $1, $16 ori $1, $0, 0x3 beq $1, $16, label_loop16_end add $25, $14, $10 jal label_loop16_start sub $21, $25, $13 label_loop16_end: ori $10, $0, 0x0 label_loop17_start: lui $22, 0x7b3e ori $14, $7, 0xb353 add $15, $22, $26 lui $29, 0xa6f1 add $3, $11, $8 sub $28, $2, $13 sub $2, $21, $14 ori $15, $20, 0x1584 lui $29, 0x4b97 lui $26, 0x871e ori $1, $0, 0x1 add $10, $1, $10 ori $1, $0, 0x3 beq $1, $10, label_loop17_end lui $19, 0x5b66 jal label_loop17_start ori $21, $28, 0x4d3e label_loop17_end: ori $3, $0, 0x0 label_loop18_start: lui $14, 0x9e71 lui $25, 0xea37 ori $0, $27, 0x7a34 lui $24, 0xed58 ori $28, $9, 0x70e0 lui $12, 0x2e80 sub $29, $16, $27 add $16, $4, $7 ori $5, $18, 0xe505 add $7, $23, $0 ori $2, $0, 0x1 add $3, $2, $3 ori $2, $0, 0x3 beq $2, $3, label_loop18_end add $11, $25, $5 jal label_loop18_start add $14, $15, $30 label_loop18_end: ori $17, $0, 0x0 label_loop19_start: lui $6, 0xe6db lui $30, 0xc107 add $1, $13, $3 ori $22, $16, 0x5a11 add $2, $16, $12 ori $5, $23, 0x92d7 add $10, $7, $29 lui $21, 0x945d add $8, $2, $10 ori $8, $16, 0xe391 ori $9, $0, 0x1 add $17, $9, $17 ori $9, $0, 0x3 beq $9, $17, label_loop19_end lui $21, 0xb1ed jal label_loop19_start add $3, $18, $19 label_loop19_end: ","date":"2023-11-12T00:00:00Z","permalink":"http://localhost:1313/p/co-p5-doc/","title":"CO | P5 - Verilog 流水线 CPU 设计文档"},{"content":"计组实验 P4 设计文档\n一、设计草稿\r希望增加的代表性指令\rbranch型：BGEZ、BGTZ、\u0026hellip;仅需修改判断条件？ bgtz：000111 rs 00000 offset if \u0026lt;cond\u0026gt; pc += 4 + sign_extend(off_set || 0^2) else pc += 4 NPC如上图修改，两个新信号分别来自ALU和CTRL CTRL：x 000111 x 0(使用0寄存器) x 0 0 IsBgtz x sub j PC = PC31..28 || instr_index || 00 NPC如上图修改，iid在main中从Instr中split出来，控制信号InsIsJ来自CTRL CTRL：x 000010 x x x 0 0 InsIsJ x x jr 其实和j修改思路差不多啊 跳转链接（jal/jalr） 相比j/jr增加了向目标寄存器写入的部分，以jalr为例：000000 rs 00000 rd 00000 001001 CTRL：001001 000000 1 x 1 0 InsIsJR x x （opCode为全0（special），需要使用func来进一步判断） GRF引出RD1到NPC lb、lh lb：100000 base rt offset `Addr ← GPR[base] + sign_ext(offset) `memword ← memory[Addr] `byte ← Addr1..0 `GPR[rt] ← sign_ext(memword7+8byte..8byte) CTRL：x 100000 0 1 2(Mem2Reg需要修改) 1 0 0 1 add main区域修改如上，Mem2Reg取1，再从CTRL中拉一个InsIsLb sb、sh sb：101000 base rt offset `Addr ← GPR[base] + sign_ext(offset) `byte ← Addr1..0 `memory[Addr]7+8byte..8byte ← GPR[rt]7:0 CRTL：x 101000 x 1 x 0 1 0 1 add sll？ 扩展alu就行，不很复杂 slt 相比前面几个比较简单，分析先不写了 支持的指令\radd, sub, ori, lw, sw, beq, lui, nop\nR型\radd: 000000 rs rt rd 00000 100000 sub: 000000 rs rt rd 00000 100010 jr: 000000 rs 00_0000_0000 00000 001000 I型\rbeq: 000100 rs rt offset(imm) lui: 001111 00000 rt imm 0 1 0 1 0 0 0 Shift ori: 001101 rs rt imm lw: 100011 base rt offset(imm) sw: 101011 base rt offset(imm) J型\rjal: 000011 imm26 指令存储器IM+程序计数器PC\rIM 容量为 16KiB（4096 × 32bit）\n端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效，置pc为0x0000_3000 2 clk I 时钟信号 3 pcNext[31:0] I 下一条指令的地址 4 pc[31:0] O 当前指令地址 5 Instr[31:0] O 将要执行的指令 功能定义\r序号 功能 描述 1 复位 同步复位，置pc为0x00003000 2 更新 在时钟上升沿，更新pc的值为pcNext 3 输出 输出当前指令地址对应指令内容 次地址计算单元NPC\r端口说明\r序号 信号名称 方向 描述 1 ALUIsZero I 指示ALU计算结果是否为0，高电平表示为0，目前用于BEQ指令 2 Branch I 指示当前指令是否为B型指令，高电平表示是B型指令，目前用于BEQ指令 3 JImm26 I 指示下条指令是否跳转到`PC31..28 Instr_index 00`，高电平表示跳转 4 JReg I 指示下条指令是否跳转到寄存器值内容，高电平表示跳转 5 ImmExtended[31:0] I 16立即数符号拓展后的32位立即数，其使用受Branch信号控制 6 Instr_index[25:0] I j、jal指令使用的26位立即数，其使用受JImm26控制 7 RsData[31:0] I jr指令跳转需要的寄存器数据，其使用受JReg控制 8 pc[31:0] I 当前指令地址 9 pcNext[31:0] O 下一条指令的地址 功能定义\r序号 功能 描述 1 输出pcNext 输出pcNext 寄存器堆GRF\r端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 WE I 写使能信号，高电平有效 4 A1[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD1 5 A2[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD2 6 A3[4:0] I 5位地址输入信号，指定寄存器位置，将WD数据写入到寄存器 7 WD [31:0] I 32位写入数据内容 8 RD1 [31:0] O 输出A1指定的寄存器的32位数据 9 RD2 [31:0] O 输出A2指定的寄存器的32位数据 功能定义\r序号 功能 描述 1 同步复位 reset有效时同步复位所有寄存器 2 读出数据 将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出 3 写入数据 当WE有效且clk上升沿来临时将WD数据写入到A3指定的寄存器 算数运算单元ALU\r端口说明\r序号 信号名称 方向 描述 1 src1[31:0] I ALU计算的第一个操作数 2 src2[31:0] I ALU计算的第二个操作数 3 ALUop[3:0] I ALU功能选择信号，MIPS-C指令集需要9种运算 4 res [31:0] O 输出计算结果 5 isZero O 指示计算结果是否为0 功能定义\r序号 功能 ALUop 描述 1 无符号加 00 res = src1 + src2 2 无符号减 01 res = src1 - src2 3 或 10 res = src1 | src2 4 src2左移16位 11 res = src2 \u0026laquo; 0x10 控制器CTRL\r完全参考教程设计 如果nop指令实现改变，考虑在此处输入Instr[31:0]进行判断\n端口说明\r序号 信号名称 方向 描述 1 func[5:0] I 指令的5-0位，对R型指令进行进一步判别 2 Opcode[5:0] I 指令的31-26位 3 TargetReg O 写入寄存器指示信号，高电平时写入rd，低电平时写入rt 4 ALUSrc O ALU功能选择信号，高电平时src2为ImmExtended，低电平时为RD2 5 Mem2Reg O 写入寄存器堆数据选择信号，高电平时从DM写入，低电平时从ALU的result写入 6 RegWrite O 高电平时寄存器堆写入使能，低电平时寄存器堆不可写入 7 MemWrite O 高电平时DM写入使能，低电平时DM不可写入 8 Branch O 高电平时指示为B型指令，低电平时指示为不是B型指令 9 JImm26 O 高电平时控制进行j、jal指令的地址跳转 10 JReg O 高电平时控制进行从寄存器读取地址的地址跳转 11 ExtOp O 高电平时EXT进行符号拓展，低电平时EXT进行0拓展 12 ALUop[1:0] O ALU运算控制信号，对应见ALU模块 功能定义\r根据func和Opcode解析指令类型，进而构建数据通路\n数据通路分析\rIns add sub ori lui lw sw beq jal jr func 10 0000 10 0010 x x x x x x 001000 op 00 0000 00 0000 00 1101 00 1111 10 0011 10 1011 00 0100 000011 000000 TargetReg 1 1 0 0 0 x x 2(31) x ALUSrc 0 0 1 1 1 1 0 x x Mem2Reg 0 0 0 0 1 x x 2(PC+4) 0 RegWrite 1 1 1 1 1 0 0 1 0 MemWrite 0 0 0 0 0 1 0 0 0 Branch 0 0 0 0 0 0 1 0 0 JImm26 0 0 0 0 0 0 0 1 0 JReg 0 0 0 0 0 0 0 0 1 ExtOp x x 0 0 1 1 1 x x ALUop add sub or shift add add sub x x 这里beq的ExtOp为1与我的实现有关\n扩展单元EXT\r端口说明\r序号 信号名称 方向 描述 1 IN[15:0] I 要扩展的16位立即数 2 ExtOp I 扩展方式控制信号，高电平时进行符号拓展，低电平时进行零拓展 3 OUT[31:0] O 扩展结果 功能定义\r根据ExtOp信号对立即数进行对应拓展\n数据存储器DM\rDM 容量为 12KiB（3072 × 32bit）\n端口说明\r序号 信号名称 方向 描述 1 reset I 同步复位信号，高电平有效 2 clk I 时钟信号 3 MemWrite I 写使能信号，高电平有效 4 MemAddr[11:0] I 12位地址输入信号，指定内存位置 5 DataWrite[31:0] I 32位写入数据内容 6 DataRead[31:0] O 32位读出数据内容 功能定义\r序号 功能 描述 1 复位 同步复位，清空所有数据 2 更新 在时钟上升沿且写使能信号有效时，更新指定地址的内容为指定数据 3 输出 输出当前内存地址对应数据内容 二、测试方案\r使用P4_TESTCODE.txt进行了基本正确性测试 使用462OJ1 Ver1.0进行了中测 三、思考题\r阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？\naddr信号来源于ALU模块计算出的要写入到DM数据的地址；使用verilog对DM进行建模的时候，往往由于mips指令集的指令要求，可以采用按字寻址的方法。因此，收到的32位地址数据，最低两位始终为0；要进行范围为1024字的寻址，需要十位的位宽，因此读取addr信号需要的位数为[11:2]。\n思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n指令对应的控制信号如何取值 1 2 3 4 5 6 7 8 9 10 11 always@(*) begin if (add) begin ALUop \u0026lt;= `ALU_add; RegWrite \u0026lt;= 1\u0026#39;b1; end else if (sub) begin ALUop \u0026lt;= `ALU_sub; RegWrite \u0026lt;= 1\u0026#39;b1; end ... end 控制信号每种取值所对应的指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 assign TargetReg = (jal) ? `REG_31 : (add || sub) ? `REG_D : `REG_T; assign ALUSrc = (ori || lui || lw || sw) ? 1\u0026#39;b1 : 1\u0026#39;b0; assign Mem2Reg = (jal) ? `FromPCAdd4 : (lw) ? `FromMem : `FromALURes; assign RegWrite = (add || sub || ori || lui || lw || jal); assign MemWrite = (sw); assign Branch = (beq); assign JImm26 = (jal); assign JReg = (jr); assign ExtOp = (lw || sw || beq); assign ALUop = (add || lw || sw) ? `ALU_add : (sub || beq) ? `ALU_sub : (ori) ? `ALU_or : (lui) ? `ALU_lui : 4\u0026#39;hf; 优劣对比：采用控制指令对应的控制信号取值的方式，是以指令的视角去找控制信号，而采用控制信号对于指令的方式则是从控制信号的视角出发。在需要拓展少量的指令时，如果能够保证之前设计的正确性，第一种方法会比较方便快捷；在较复杂的系统中，如果要从控制信号出发去寻找出错的地方，第二种地方会更便于debug。 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n同步复位：clk信号优先级更高，只有clk上升沿到来时才根据reset信号判断是否需要复位 异步复位：reset信号优先级更高，只要reset信号有效，都无视clk信号进行电路复位 C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n以addi和addiu对比为例，考察他们的RTL语言描述，区别在于addi指令使用了GPR[rs]的最高位和原32位数据进行拼接，通过判断加法完毕后结果的最高两位是否一致（实际上同时判断了向更大正数和更小负数的溢出），考虑是否raise SignalException(IntegerOverflow)。如果不考虑溢出，二者失去唯一的区别。add和addu同理。\n","date":"2023-11-05T00:00:00Z","permalink":"http://localhost:1313/p/co-p4-doc/","title":"CO | P4 - Verilog 单周期 CPU 设计文档"},{"content":"计组实验 P3 设计文档\n前言\r按照2206级的安排，实验Pre~P2挂了也可以继续向后，而从P3开始才是计组实验最美味原汁原味的部分，不得不尝\nP3要求使用Logisim开发单周期CPU，课下要求支持8条基础指令，课上则是增加指令。需要注意这也是计组实验最后一次硬性要求使用Logisim，因此最好在课下就针对典型指令尝试做拓展并测试，以求一次通过课上、早日开始verilog部分。按照往届经验题型一般是跳转 + 计算 + 访存，而且不会出指令集中已有的指令。本文最后有对典型指令实现的分析，可以参考\n一、设计草稿\r支持的指令\radd, sub, ori, lw, sw, beq, lui, nop\nR型\radd: 000000 rs rt rd 00000 100000 sub: 000000 rs rt rd 00000 100010 I型\rbeq: 000100 rs rt offset(imm) lui: 001111 00000 rt imm 0 1 0 1 0 0 0 Shift ori: 001101 rs rt imm lw: 100011 base rt offset(imm) sw: 101011 base rt offset(imm) 指令存储器IM+程序计数器PC\r端口说明\r序号 信号名称 方向 描述 1 reset I 异步复位信号，高电平有效，置pc为0x0000_3000 2 clk I 时钟信号 3 pcNext[31:0] I 下一条指令的地址 4 pc[31:0] O 当前指令地址 5 Instr[31:0] O 将要执行的指令 功能定义\r序号 功能 描述 1 复位 异步复位，置pc为0x00003000 2 更新 在时钟上升沿，更新pc的值为pcNext 3 输出 输出当前指令地址对应指令内容 次地址计算单元NPC\r端口说明\r序号 信号名称 方向 描述 1 ALUIsZero I 指示ALU计算结果是否为0，高电平表示为0，目前用于BEQ指令 2 IsBeq I 指示当前指令是否为BEQ，高电平表示是BEQ，目前用于BEQ指令 3 pc[31:0] I 当前指令地址 4 pcNext[31:0] O 下一条指令的地址 功能定义\r序号 功能 描述 1 输出 输出pcNext 寄存器堆GRF\r端口说明\r序号 信号名称 方向 描述 1 reset I 异步复位信号，高电平有效 2 clk I 时钟信号 3 WE I 写使能信号，高电平有效 4 A1[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD1 5 A2[4:0] I 5位地址输入信号，指定寄存器位置，读出寄存器数据到RD2 6 A3[4:0] I 5位地址输入信号，指定寄存器位置，将WD数据写入到寄存器 7 WD [31:0] I 32位写入数据内容 8 RD1 [31:0] O 输出A1指定的寄存器的32位数据 9 RD2 [31:0] O 输出A2指定的寄存器的32位数据 功能定义\r序号 功能 描述 1 异步复位 reset有效时异步复位所有寄存器 2 读出数据 将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出 3 写入数据 当WE有效且clk上升沿来临时将WD数据写入到A3指定的寄存器 算数运算单元ALU\r端口说明\r序号 信号名称 方向 描述 1 src1[31:0] I ALU计算的第一个操作数 2 src2[31:0] I ALU计算的第二个操作数 3 ALUop[1:0] I ALU功能选择信号 4 res [31:0] O 输出计算结果 5 isZero O 指示计算结果是否为0 功能定义\r序号 功能 ALUop 描述 1 无符号加 00 res = src1 + src2 2 无符号减 01 res = src1 - src2 3 或 10 res = src1 | src2 4 src2左移16位 11 res = src2 \u0026laquo; 0x10 控制器CTRL\r完全参考教程设计 如果nop指令实现改变，考虑在此处输入Instr[31:0]进行判断\n端口说明\r序号 信号名称 方向 描述 1 func[5:0] I 指令的5-0位，对R型指令进行进一步判别 2 Opcode[5:0] I 指令的31-26位 3 ToRegD O 写入寄存器指示信号，高电平时写入rd，低电平时写入rt 4 ALUSrc O ALU功能选择信号，高电平时src2为ImmExtended，低电平时为RD2 5 Mem2Reg O 写入寄存器堆数据选择信号，高电平时从DM写入，低电平时从ALU的result写入 6 RegWrite O 高电平时寄存器堆写入使能，低电平时寄存器堆不可写入 7 MemWrite O 高电平时DM写入使能，低电平时DM不可写入 8 IsBeq O 高电平时指示为BEQ指令，低电平时指示为不是BEQ指令 9 ExtOp O 高电平时EXT进行符号拓展，低电平时EXT进行0拓展 10 ALUop[1:0] O ALU运算控制信号，对应见ALU模块 功能定义\r根据func和Opcode解析指令类型，进而构建数据通路\n数据通路分析\rIns add sub ori lui lw sw beq func 10 0000 10 0010 x x x x x op 00 0000 00 0000 00 1101 00 1111 10 0011 10 1011 00 0100 ToRegD 1 1 0 0 0 x x ALUSrc 0 0 1 1 1 1 0 Mem2Reg 0 0 0 0 1 x x RegWrite 1 1 1 1 1 0 0 MemWrite 0 0 0 0 0 1 0 IsBeq 0 0 0 0 0 0 1 ExtOp x x 0 0 1 1 1 ALUop add sub or shift add add sub 这里beq的ExtOp为1与我的实现有关\n扩展单元EXT\r端口说明\r序号 信号名称 方向 描述 1 IN[15:0] I 要扩展的16位立即数 2 ExtOp I 扩展方式控制信号，高电平时进行符号拓展，低电平时进行零拓展 3 OUT[31:0] O 扩展结果 功能定义\r根据ExtOp信号对立即数进行对应拓展\n二、测试方案\r根据最后一道思考题的改进版实现了如下代码，使用MARS进行对拍测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 sub $s0, $a0, $a2 # 正正 sub $s1, $a0, $a3 # 正负 sub $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $t0, $0, 0x0020 sw $a0, 0($t0) sw $a1, -4($t0) sw $a2, -8($t0) sw $a3, -12($t0) lw $a0, 0($t0) lw $a1, -12($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) sub $a1, $a1, $a0 nop beq $a1, $a2, loop2 # 相等 nop 三、思考题\r上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。\n状态存储：PC、GRF、DM 状态转移：NPC、ALU、CTRL、EXT\n现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。\n合理。\nROM for IM：指令在程序运行时不允许被改变，ROM的特性正好适合实现IM RAM for DM：RAM速度快，可读可写，适应了存储加载型指令的要求 Register for GRF：寄存器堆使用寄存器实现是合情合理的，寄存器可以高速读写，且寄存器个数少且固定，不必使用RAM 改进：现代计算机指令和数据不分开存储，IM和DM共用一块空间，只不过在分别的功能实现时会严格区分区域，因此可以考虑还原这种实现；现在我的DM采用按字存储，无法直接实现半字级或字节级的读取修改。 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。\n暂时没有实现其他的模块。\n事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？\nnop在CPU运行周期内不需要对控制信号产生任何高电平（pc自增4不需要CTRL模块进行控制），本版实现中nop对应的指令码为0x00000000，不会产生任何控制信号，即相当于执行了nop指令；若后续要求改变nop的指令码且产生了冲突，可考虑在CTRL模块传入Instr进行特判，只要保证不产生控制信号高电平即可。\n阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。\nori: 为寄存器构造正值 lui: 为寄存器构造负值 add: 利用ori和lui构造好的数据进行三种类型的加法测试 sub: 未测试 sw: 未覆盖offset值为负数的情况 lw: 未覆盖offset值为负数的情况 beq: 覆盖两种情况，但未覆盖offset值为负数的情况 nop: 未测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 sub $s0, $a0, $a2 # 正正 sub $s1, $a0, $a3 # 正负 sub $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $t0, $0, 0x0020 sw $a0, 0($t0) sw $a1, -4($t0) sw $a2, -8($t0) sw $a3, -12($t0) lw $a0, 0($t0) lw $a1, -12($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) sub $a1, $a1, $a0 nop beq $a1, $a2, loop2 # 相等 nop 四、实验前准备\rbranch型：BGEZ、BGTZ、\u0026hellip;仅需修改判断条件？ bgtz：000111 rs 00000 offset if \u0026lt;cond\u0026gt; pc += 4 + sign_extend(off_set || 0^2) else pc += 4 NPC如上图修改，两个新信号分别来自ALU和CTRL CTRL：x 000111 x 0(使用0寄存器) x 0 0 IsBgtz x sub j PC = PC31..28 || instr_index || 00 NPC如上图修改，iid在main中从Instr中split出来，控制信号InsIsJ来自CTRL CTRL：x 000010 x x x 0 0 InsIsJ x x jr 其实和j修改思路差不多啊 跳转链接（jal/jalr） 相比j/jr增加了向目标寄存器写入的部分，以jalr为例：000000 rs 00000 rd 00000 001001 CTRL：001001 000000 1 x 1 0 InsIsJR x x （opCode为全0（special），需要使用func来进一步判断） GRF引出RD1到NPC lb、lh lb：100000 base rt offset Addr ← GPR[base] + sign_ext(offset) memword ← memory[Addr] byte ← Addr1..0 GPR[rt] ← sign_ext(memword7+8*byte..8*byte) CTRL：x 100000 0 1 2(Mem2Reg需要修改) 1 0 0 1 add main区域修改如上，Mem2Reg取1，再从CTRL中拉一个InsIsLb sb、sh sb：101000 base rt offset Addr ← GPR[base] + sign_ext(offset) byte ← Addr1..0 memory[Addr]7+8*byte..8*byte ← GPR[rt]7:0 CRTL：x 101000 x 1 x 0 1 0 1 add 具体改造直接参考学长的实现如下： sll？ 扩展alu就行，不很复杂 slt 相比前面几个比较简单，分析先不写了 ","date":"2023-10-29T00:00:00Z","permalink":"http://localhost:1313/p/co-p3-doc/","title":"CO | P3 - Logisim 单周期 CPU 设计文档"}]