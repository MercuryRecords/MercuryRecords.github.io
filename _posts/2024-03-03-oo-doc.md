---
layout: post
title: OO | Unit 1
date: 2024-03-03 13:00:00 +0800
categories: [OO]
description: 面向对象第一单元作业总结博客
keywords: OO
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 第一单元博客

## 一、整体设计的量化分析

### 1、类图和优缺点分析

<div align="center">
<img src="/images/posts/OO/unit1-uml.png">
</div>

- 入口类：`MainClass`
- 计算类：`Poly`、`Mono`
- 解析主体类：`Lexer`、`Parser`
- 工具类：处理自定义函数定义和调用的 `FuncExpander`、从字符串分析成分并用于优化的 `Recognizer`
- 文法成员类：`Expr`、`Term`、`Variable`、`Number`，没有指数函数是因为偷懒直接调用计算类构建了

优点：层次清晰、方法简明，使用解析主体类和文法成员类配合完成递归下降解析，计算类负责存储输出表达式的组分和边解析边化简
缺点：两个计算类耦合程度较高（见后续分析），可以单独提取一个计算器功能的类；对包的理解不够深刻，基本是看心情和直觉决定放在 `expr` 文件夹内与否

### 2、代码规模分析

使用 `Statistic` 协助分析


<div align="center">
<img src="/images/posts/OO/unit1-codelines.png">
</div>

可以发现文法成员类和入口类的代码行数都很少，这是因为他们的属性、方法个数都很少，方法规模基本转移到调用的类中了

- `Parser` 类实现了使用循环语句解析表达式层次、使用分支语句覆盖多种因子类别的功能；
- `Poly` 类和 `Mono` 类需要实现取负、加法、乘法、乘方、合并等计算、满足数据结构要求而重写的 `equals` 和 `hashCode` 方法、用于表达式输出而重写的 `toString` 方法、针对业务需求写了多种构造方法等。

### 3、代码复杂度分析

使用 `Metrics` 协助分析，包括分析各指标中前6复杂的典型方法

1. **认知复杂度 `CogC`**：简单来说就是衡量方法的理解难度，与控制流结构的复杂程度有关，注意与圈复杂度区分

<div align="center">
<img src="/images/posts/OO/unit1-cogc.png">
</div>

- 表达式输出优化相关：`Mono.toString`、`Poly.asString`、`Recognizer.isExponent`、`Mono.canBeTeared` 都属于输出化简后表达式导致的理解难度，要在考虑文法的同时优化总长度并进行输出，势必要引入一些特殊规则的判断，如特定的0能不能不输出、特定的系数1能不能不输出、指数函数能否变化为带幂次的形式而减少括号、输出表达式的时候有没有系数为正的单项式可以提前输出，个人认为在保证正确性和性能分的前提下增加认知复杂度是情有可原的；
- 计算相关 `Poly.powerTrans`：为了统一形式和实现“边解析边化简”，我选择实现这个方法以计算对应多项式的幂次结果。方法中包含了幂次为0的预剪枝、主体进行指定次数（小于等于8次）的乘法，故包含了3层循环。这里可以提取一个乘法方法；
- 解析相关 `Parser.parseFactor`：由因子多样性导致有多个 `if-else` 分支。

2. **基本复杂度 `ev(G)`**：衡量程序非结构化程度

<div align="center">
<img src="/images/posts/OO/unit1-evg.png">
</div>

- 字符串相关：后四种都与字符串逐个解析有关，字符串肯定会有很多判断语句不可避免；
- `Mono.equals`：重写中涉及了较多预剪枝，尽量不碰到指数函数因子部分的相等判断，个人认为是值得的。

3. **模块设计复杂度 `iv(G)` 和圈复杂度 `v(G)`**：主体都是圈复杂度中对于独立路径条数的计算，结果差不多故放在一起

<div align="center">
<img src="/images/posts/OO/unit1-ivg.png">
</div>

- 这些方法在上文已经分析过了，不再赘述

4. **类复杂度分析**：

<div align="center">
<img src="/images/posts/OO/unit1-classmetrics.png">
</div>

- 加权复杂度较高的 `Poly` 类和 `Mono` 类：在代码规模分析中其实可以预测到这里表现较差了，优化空间个人认为只剩下把计算相关的功能单独提一个类出来，但这并不能改良计算本身的复杂性；
- 平均操作复杂度较高的 `Recognizer`类：这个类表现较差倒是意料之外情理之中，我猜主要是由于依据文法规则逐字解析字符串和 `Recognizer.isNumber` 方法受类中另外两个方法调用导致。

## 二、从迭代看架构

### 1、第一次作业架构

问题重述：读入一个单变量表达式，输出变形后不含括号的等价表达式，在保证正确的前提下使得输出表达式尽量短。
1. **预处理方法**：经过分析发现去除空白字符是性价比最高的预处理方法，在 `Lexer` 的构造方法中直接实现了；讨论和观察中注意到大部分同学还对正负号进行了预处理，但我认为遵循形式化表述并在适当的地方使用 `parseSign` 方法即可。

``` java

// Parser.java
// 使用true代表正号，false代表负号
    public Boolean parseSign() {
        if (lexer.peek().equals("+")) {
            lexer.next();
            return true;
        } else if (lexer.peek().equals("-")) {
            lexer.next();
            return false;
        } else {
            return true;
        }
    }

```
2. **表达式的读入和解析：** 从形式化表述可以发现表达式具有明显的树状结构，结合前置知识和对应练习自然地想到利用递归下降的思想进行解析，因此程序复用了练习中 advance 的递归下降结构。在递归下降的解析过程中，重要的是改写指导书给出的形式化表述，比如可以写成右递归或者带循环的形式。笔者采用了带循环的形式，改写如下（不考虑空白项）：
    - 表达式：` [加减] 项 {加减 项} `
    - 项：` [加减] 因子 {'*' 因子} `
    - 因子：` 'x' [空白项 指数] | [加减] 允许前导零的整数 |  '(' 表达式 ')' [空白项 指数] `
    - ...
    由此引出 `Parser` 类中的五个用于解析组分的方法：`parseExpr()` 、 `parseTerm()` 、 `parseFactor()` 、 `parseSign()` 、 `parseExponent()` 。
3. **边建树边合并：** 这里其实也呼应了上一段中使用 `HashMap` 来表示语法树的用意，我在完成项目的途中始终想的是树的结构，但实现看不到典型的结点等概念，因为在各对象构建语法树的过程中都可以将语法树保持为深度为 1 的多项式树。这个想法只需要 `Expr` 和 `Term` 类中的方法实现边建树边合并，即 `Expr` 新增项时实现加法， `Term` 新增因子时实现乘法。
4. **各组分的存储结构：** 考虑到使用递归下降对表达式进行解析，解析过程中的表达式、项、因子其实都是整棵抽象语法树的子树，所以对于各个语法对象其实都可以使用一个树结构进行存储。具体到表达式这个问题上，通过分析一定是叶子节点的变量因子和常数因子可以发现，第一次作业中的表达式总等价于一个多项式，这也是我们想要的 **不含括号的等价表达式** 。要表示一个多项式，其实只需要使用 `HashMap` 来存储次数和系数的键值对，就可以利用其一直完成到最后的表达式输出。所以可以构建一个接口 `SynComp` （文法组分），其中提供 `getPoly()` 等方法。

可以看到这里的**4. 组分存储结构**导致为了hw2势必要进行重构，放一个生前的类图吧


<div align="center">
<img src="/images/posts/OO/unit1-hw1.png">
</div>

这次作业（hw1）的架构可以看出，每个 `Factor` 的实现中都有一个 `poly` 属性，实现对应组分的存储，仅考虑了幂函数的次数和系数，这样的可拓展性是相当差的；而且将 `powerTrans` 作为接口中的方法要求，实际上这个方法只有 `Expr` 一个类有用法，违反了SOLID原则中的**接口隔离原则**。

### 2、第二、三次作业架构

#### 重构后架构设计

1. **哎，重构：** 相比hw1增加了指数函数和自定义函数的部分，个人认为指数函数提升了对自定义类的要求，毕竟如果hw1像苯人一样

> 使用 `HashMap` 来存储次数和系数的键值对

而不考虑可拓展性的话，就要付出惨痛的重构代价。就本次作业而言，一个必然满足正确性要求的输出形式为 $ Q(x)=\sum^{i} a_i*x^{b_i}*exp(c_i) $ 、$ c_i=Q(x') $。个人也建议从输出形式倒推自定义类的设计，这样不仅利于最后的输出，也利于在使用递归下降等方法解析表达式的时候进行**边建树边合并**。言归正传，本次作业我设计了 `Mono` 类和 `Poly` 类作为“基类”，原有的 语法成分类 利用这两个类进行计算和合并等操作。

1. **指数函数：** 基于 `Mono` 类，要实现指数函数的解析、运算和存储都不算难事。

2. **自定义函数：** 
   - 已有的架构无法**完全**处理自定义函数，势必是要创建一个新的类进行解析的。这个类要实现对自定义函数声明/定义的解析，包括**存储形参、函数表达式**。
   - 为了保证逻辑的统一性，解析自定义函数的方法应该被解析因子的方法调用，同样地返回一个 `Factor` 或 `Poly` 类的值。
   - 如果能保证处理好本次作业除自定义函数的部分，一个简单的处理自定义函数调用的方法是**将函数表达式中的形参换为实参，再调用 `Parser` 类进行解析**。这样能提高代码的复用率，满足上述的架构要求，耦合度也相对较低。

3. **微分因子：** 对多项式 `Poly` 类使用加法法则，对扩展单项式 `Mono` 类使用乘法法则即可。

#### 重构后实现要点


1. **自定义类的深克隆问题：** 注意到在表达式$Q(x)=\sum^{i} a_i*x^{b_i}*exp(c_i)$ 中， $c_{i}$ 代表的是因子，在进行所有必要的展开之后，它最坏是一个表达式。因此你可能会在 `Poly` 类中使用容器存储 `Mono` 对象，又在 `Mono` 类中使用 `Poly` 对象表示指数函数的指数。务必注意检查是否使用了**深克隆**而非**浅克隆**，因为在解析和化简的过程中难免对这些对象进行运算，对克隆的疏忽容易导致**灾难性的后果**。

2. **合并同类项的双刃剑——重写equals与hashcode方法：** 要进行同类项的合并，我们需要比较 `Mono` 对象的 x 幂次和指数内容，一个直接的想法是**重写equals与hashcode方法**从而能够直接比较两个对象是否相等。需要注意的是考虑到上一个问题中涉及的 `Mono` 类和 `Poly` 类的嵌套，这个地方的重写需要充分的考虑，在 `Poly` 类中利用 `HashMap` 结构完成各 `Mono` 对象的相等判断，在 `Mono` 类中注意对指数函数中指数项的相等判断。

3. **指数函数的输出：** 注意指数函数的指数是**因子**，在输出的时候应该呈现因子，**不能直接输出表达式**；在化简时也可以考虑将表达式因子尽可能降到常数因子和幂函数等形式，有助于提高性能分。

4. **自定义函数相关：** 形参替换的时候如果不作处理，容易改变`exp`中的`x`，已有同学在讨论区提出解决方法；将实参代入形参的时候应该**使用括号括起实参**，否则可能导致表达式的运算优先级发生改变。

### 3、重构体验

几乎是在一看到第二次作业要求时就意识到了重构的必要性，其实主要的时间都在思考能不能避免 `Mono` 类和 `Poly` 类的反复嵌套，最终还是接受了这种实现。主要的心路历程是空想时的痛苦和怀疑、战战兢兢地写代码害怕无法实现、和最后发现“诶，好像没事”。虽然反复嵌套比较难看、耦合程度较高，但是在题目数据范围内是比较快速有效的实现了。

### 4、迭代场景畅想

- 增加新的函数因子：比如类似往届引入三角函数，这个正确性处理上和指数函数思路一样，为 `Mono` 类新加属性即可，并且以此为基础审阅所有相关计算方法是否正确
- 增加变量类型：如果从单变量扩展到多变量，也是需要增加新属性，检查相关方法
- 增加变换方法：如增加积分，新增方法返回指定参数下的计算结果即可，虽然能不能算出来是另外一个问题了

整体来说，只要不跳出表达式化简的这个大目标，现有的架构对新需求的可扩展性表现较好，毕竟我处理第三次作业只需要更新不到50行代码。

## 三、bug分析

就课程组评测而言，印象中只在hw2的重构过程中提交的一次中测发现了bug，主要是因为*重构写的急*导致字符串替换时出现的问题（将*exp*替换为*E*后忘记替换回来），发现后很快解决了。

查看Git日志后发现，hw1主要是对样例debug就结束了，因为没有别的方法找bug所以搓了**评测机**，开启了unit1的不归路（？

hw2经历了大重构，多数的bug也在这里发现，从Git日志中可以看出主要的bug似乎还是从自己的评测机中测出来的，包括没有遵循文法导致exp内部的表达式因子没有加括号等等

如果把开发过程中发现的bug也算入在内的话，我认为得通过**开始写代码前写个todolist**来解决，这样可以避免陷入局部忘记整体。

互测阶段有一个自己测出自己的bug，当真有点汗流浃背：

```
3
g(z)=exp(exp(exp(exp(z))))
f(y)=exp(exp(exp(exp(g(y)))))
h(x)=exp(exp(exp(exp(f(x)))))
h(h(h(exp(exp(exp(exp(x^8)))))))
```

这个形式的数据会导致我和互测房间中的多人产生 `TLE`，我使用了 `JProfiler` 进行性能分析，发现是在输出过程中递归调用了太多次的 `toString` 方法，随着 `exp` 的嵌套运行时间应该是**指数级**提升。经过修改一些代码语句来规避对 `toString` 的调用即可。

```java
// Poly.java
    public String asString(boolean asFactor) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        Mono firstMono = firstPositive();
        // Modified here
        // if (firstMono != null && !firstMono.toString().isEmpty()) { 
        if (firstMono != null) {
            sb.append(firstMono);
            first = false;
        }
        for (Mono mono: this.mos.keySet()) {
            // Modified here
            // if (mono.toString().isEmpty() || mono.equals(firstMono)) {
            if (mono.equals(firstMono) || mono.toString().isEmpty()) {
                continue;
            }
            if (!first && !mono.isNegative()) {
                sb.append("+");
            }
            sb.append(mono);
            first = false;
        }
        if (sb.length() == 0) {
            sb.append("0");
        }
        if (asFactor && !canBeSimplified(sb.toString())) {
            sb.insert(0, '(');
            sb.append(')');
        }
        return sb.toString();
    }
```

两处修改分别为**避免冗余的并判断**和**提前短路或判断**，前者似乎不是什么可以复用的设计技巧，毕竟我更偏向于保留一些冗余的保险设计；后者倒是在发现时可以调整一下，毕竟不影响正确性。

代码行数来讲两者无差异，圈复杂度倒是由于if条件的简化下降了**1**，这应该属于通过减少无效判断来降低复杂度。此外，要降低方法的复杂度，主要是要遵守单一职责原则、对函数进行拆分和重构。通过查阅网上的资料，我发现还有一些常用的方法可以降低方法的复杂度，包括使用卫语句替换嵌套 `if-else` 语句、减少 `return` 语句的使用、减少使用控制标记变量等方法，但我认为重要的是在方法复杂度和方法功能中进行取舍，要避免写出又臭又长的代码，也不能为了追求低复杂度而过分拆分方法。

## 四、hack分析

测试策略：自动手动相结合。

### 1、评测机

[开源链接](https://github.com/MercuryRecords/BUAA_OO_2024)

1. 首先是hw1借助学长提供的评测机架构，利用python的`sympy`等库，基本实现了自动化生成数据、正确性判定和hack数据导出，也实现了cost计算。
2. hw2时间紧张，但还是实现了指数函数和自定义函数的生成，判断正确性方面考虑到sympy库的性能有点差，最终使用了**对拍**的方法，事实证明面对OO互测这样的场景对拍是一个简单有效的方法，就算在互测前也可以和友人对拍；而且sympy只能实现对答案正确性的部分判断，即它能接受`exp(-x)`等不符合文法的化简结果，面对这种情况我的解决方法是确保自己的程序（或者某个别人的程序）对文法的读取非常严格，将其作为**文法检查器**，对别人输出的表达式进行读入解析再输出，这种做法也相当有效。
3. 评测机**加入了对 `TLE` 的考虑**，其实在hw2已经出现了有几组数据运行时间过长的情况，但考虑到生成输入、正确性判断使用了sympy等因素，我并没有深究其中原因。在hw3中尝试利用生成概率控制表达式的复杂度，并加入了程序只能运行10s的限制，由此提供了对TLE的支持。

### 2、手动测试

手动测试的流程发生在自动评测之后，毕竟这就是自动评测机的意义。对于已经有报错数据的程序，我会尝试查找它们出错的原因，并根据代码情况考虑是否会有相关的bug产生；对于没有报错数据的程序，我会更细致地阅读它们的内容，综合一次作业中的典型错误进行排查。

### 3、结合实际情况的分析

- **hw1：** 相当和平，我的房间没人中刀，这个时候怀疑过评测机是不是写错了
- **hw2：** 惨烈的战役，自动化测试中发现有的程序输出了类似 `exp(-x)` 的内容，在手动构造测试样例的时候发现了还有同学会将负数系数作为幂次提出，这也违反了文法的要求，所以战果是产生了一刀四爆 =)；此外自动测试还发现一个同学的报错有 `substring` 访问越界和 `BigInteger divide by zero` 的问题，第一个问题如果别的程序有应该早能自动测试查出来了，而第二个问题是因为该同学的程序实现了除法，似乎是为了优化相关的工作，而其他同学基本没有考虑到使用公因子提取进行优化，故这个问题其他同学也不存在。这次互测是**究极大乱斗**，我hack出的每个bug应该都和别的同学共享了战果，所以虽然刀中了5个人应该得分也不算高。
- **hw3：** 一家独大的战役，这次使用评测机测出了2个 `TLE`、一个 `StackOverflowError`、一个 `WA`。大家的 `TLE`基本都是架构中反复调用次数太多导致的，`StackOverflowError` 是反复调用导致超时之前先爆栈了，很难说谁的重构难度比较大。`WA` 的同学似乎是在同类项合并上栽了跟头，居然在hw2中没有被测出来（）本来做到这里感觉已经无可hack了，但在友人的提示下发现**多层嵌套的 `exp()` 也能导致超时**（之前评测机测出的 `TLE` 是幂次运算时间太久导致的），这个样例让我的程序也被攻破，只能说还好同房没有发现这个数据。其实我在hw2便注意到了 `exp` 对cost的影响很小，但当时并没有想到借此构造极端数据，因为 `exp()` 本身就有5个字符之长了，而且hw2中函数不支持嵌套；hw3中**开放了函数嵌套**提供了对架构简洁性进行测试的可能，导致可以在相当符合规则的程度上进行hack。通过构造一个极端数据点，本次互测又成功多刀一人。这次互测刀中了5个人，独享了4个人的经验=)。

## 五、优化分析

### 1、优化内容

`Mono` 层：
- 如果系数为0返回空字符串，让 `Poly` 层决定接下来的处理。
- 系数不为0时考虑按照 **系数 - 带次数的x - 指数函数** 的顺序进行输出。
- 如果次数不为0/指数函数部分存在 且 系数绝对值为1，可以省略系数。 e.g. `1*x -> x`
- 如果次数为0不输出 `x` 部分；如果次数为1不输出 `^n` 部分。
- 对指数函数部分，利用子方法 `canBeTeared` 来判断能否将指数函数进一步化简。 e.g. `exp((3*x^4)) -> exp(x^4)^3`
- 利用标识变量决定要不要输出 `*` 来连接各部分。

`Poly`层：
- 正项提前输出。 e.g. `-x+1 -> 1-x`
- 确保各单项式之间仅用一个正号或符号连接。
- 如果作为因子输出，利用子方法 `canBeSimplified` 来判断是否要作为表达式因子而加括号。e.g. `exp((3)) -> exp(3)`

考虑到个人能力、开发耗时和程序耗时，我没有选择对 `Poly`层进行更多的化简，包括提取公因子、拆分exp等方法。

### 2、优化分析

感觉这里有点像开放封闭原则，即就算要优化输出表达式的长度，也不应该影响输出表达式的正确性。我的代码保持了简洁性和正确性，如果要按上文进行提取公因子、拆分exp的优化，确实可能对这两者产生危害，所以不妨在要进行进一步优化的前提下思考解决方案。这里应该**贯彻开放封闭原则**，保护已经有简洁性和正确性的代码，新开方法进行优化。当然这一定程度上会和程序耗时产生冲突。
比如，公因子提取肯定是要发生在一次输出之前的，可以考虑对 `Poly` 类新增边合并边计算gcd的功能，让字符串输出之前可以通过访问属性来优化输出，这也能降低程序的耦合程度；关于如何拆分exp也应该随着对象内容的更新而实时更新，让 `toString` 方法直接调用而非计算。

## 六、心得体会

- 及时拆分方法，常常跳出局部看全局。
- Unit1整体对层次化的要求感觉跟OOPre差不多，但毕竟经历了OOPre的磨练，感觉Unit1整体的代码分布很和谐，看着重构完不错的架构感觉很爽，当然重构是痛苦的。
- 前两周OO花的时间实在是太多了，很奇怪的难度曲线，我是完全独立完成的hw1，很难想象一个初学者如何能在不参考学长博客的情况下写出高拓展性的架构，hw2发现我所想和学长架构差不多的时候是感到庆幸的。
- 多多考虑可拓展性，我的程序在第一次作业支持了嵌套括号，第二次作业支持了自定义函数嵌套，多做些不过分的考虑。
- 伟大的评测机，写评测机的过程也对作业本身有加深理解的作用。感谢学长提供的第一次作业评测机架构，和从hw2开始和我一起开发评测机的yez同学。希望大家多多开源评测机交流！

## 七、方向建议

- 第一单元的性能分可以考虑计算运行时长等，占比较小，希望多测几次预防服务器波动
- 缩短互测hack间隔，要拿满基础分至少要花2.5h（A房）